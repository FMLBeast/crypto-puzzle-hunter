{
  "core_modules": [
    {
      "name": "core.enhanced_state_saver",
      "path": "core/enhanced_state_saver.py",
      "docstring": "\nEnhanced State Saver and Output Manager for Crypto Hunter\nProvides comprehensive state persistence and organized output generation\n",
      "imports": [
        "import os",
        "import json",
        "import time",
        "import hashlib",
        "import zipfile",
        "import base64",
        "import binascii",
        "from pathlib import Path",
        "from typing import Dict",
        "from typing import Any",
        "from typing import List",
        "from typing import Optional",
        "from typing import Tuple",
        "from datetime import datetime",
        "import logging",
        "from core.logger import solution_logger",
        "from core.state import State",
        "import re",
        "import re",
        "import re",
        "import re",
        "import re",
        "import re",
        "import base64"
      ],
      "functions": [],
      "classes": [
        {
          "name": "EnhancedStateSaver",
          "docstring": "Enhanced state saving with comprehensive output organization",
          "line_number": 21,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self, output_dir: str, results_dir: str)",
              "docstring": null,
              "line_number": 24,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "load_state",
              "signature": "(self, puzzle_path: str) -> Optional['State']",
              "docstring": "\n        Load a previously saved state for a puzzle\n\n        Args:\n            puzzle_path: Path to the puzzle file\n\n        Returns:\n            State object if found, None otherwise\n        ",
              "line_number": 32,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_setup_directories",
              "signature": "(self)",
              "docstring": "Set up all necessary directories",
              "line_number": 112,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "save_comprehensive_results",
              "signature": "(self, state, puzzle_path: str, create_compressed: bool) -> Dict[str, str]",
              "docstring": "\n        Save comprehensive analysis results with organized output files\n\n        Args:\n            state: Final puzzle state\n            puzzle_path: Path to the puzzle\n            create_compressed: Whether to create a compressed archive\n\n        Returns:\n            Dictionary of saved file paths\n        ",
              "line_number": 133,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_puzzle_name",
              "signature": "(self, puzzle_path: str) -> str",
              "docstring": "Extract a clean puzzle name from the path",
              "line_number": 260,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_safe_write_json",
              "signature": "(self, filepath: Path, data: Dict[str, Any])",
              "docstring": "Safely write JSON data with error handling",
              "line_number": 268,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_create_main_results",
              "signature": "(self, state, puzzle_path: str) -> Dict[str, Any]",
              "docstring": "Create the main results dictionary with comprehensive data",
              "line_number": 277,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_sanitize_transformation",
              "signature": "(self, transformation: Dict[str, Any]) -> Dict[str, Any]",
              "docstring": "Sanitize transformation data for JSON serialization",
              "line_number": 324,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_calculate_analysis_duration",
              "signature": "(self, state) -> Optional[str]",
              "docstring": "Calculate analysis duration from timestamps",
              "line_number": 334,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_count_high_confidence_extractions",
              "signature": "(self, state) -> int",
              "docstring": "Count high-confidence steganographic extractions",
              "line_number": 347,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_save_html_report",
              "signature": "(self, state, puzzle_path: str, report_path: Path)",
              "docstring": "Save a comprehensive HTML report",
              "line_number": 356,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_html_report",
              "signature": "(self, state, puzzle_path: str) -> str",
              "docstring": "Generate HTML report content",
              "line_number": 365,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_save_analysis_report",
              "signature": "(self, state, puzzle_path: str, report_path: Path)",
              "docstring": "Save a detailed analysis report in Markdown format",
              "line_number": 503,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_save_steganography_data",
              "signature": "(self, state, base_name: str) -> Dict[str, str]",
              "docstring": "Save extracted steganographic data to separate files",
              "line_number": 566,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_save_binary_data",
              "signature": "(self, state, base_name: str) -> Dict[str, str]",
              "docstring": "Save binary data extractions",
              "line_number": 621,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_try_decode_string",
              "signature": "(self, data_str: str) -> Optional[bytes]",
              "docstring": "Try to decode a string as hex, base64, or other formats",
              "line_number": 667,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_save_potential_keys",
              "signature": "(self, state, base_name: str) -> Dict[str, str]",
              "docstring": "Save potential cryptographic keys found in the analysis",
              "line_number": 698,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_find_hex_keys",
              "signature": "(self, text: str, transform: Dict[str, Any]) -> List[Dict[str, str]]",
              "docstring": "Find hex strings that could be cryptographic keys",
              "line_number": 764,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_find_wif_keys",
              "signature": "(self, text: str, transform: Dict[str, Any]) -> List[Dict[str, str]]",
              "docstring": "Find WIF format private keys",
              "line_number": 790,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_find_mnemonic_phrases",
              "signature": "(self, text: str, transform: Dict[str, Any]) -> List[Dict[str, str]]",
              "docstring": "Find potential BIP39 mnemonic phrases",
              "line_number": 808,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_find_ethereum_addresses",
              "signature": "(self, text: str, transform: Dict[str, Any]) -> List[Dict[str, str]]",
              "docstring": "Find Ethereum addresses",
              "line_number": 834,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_find_bitcoin_addresses",
              "signature": "(self, text: str, transform: Dict[str, Any]) -> List[Dict[str, str]]",
              "docstring": "Find Bitcoin addresses",
              "line_number": 852,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_is_potential_mnemonic",
              "signature": "(self, phrase: str) -> bool",
              "docstring": "Basic check if a phrase could be a BIP39 mnemonic",
              "line_number": 870,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_save_transformations",
              "signature": "(self, state, base_name: str) -> Dict[str, str]",
              "docstring": "Save all transformations as individual files",
              "line_number": 885,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_save_execution_log",
              "signature": "(self, state, log_path: Path)",
              "docstring": "Save execution log with all insights in chronological order",
              "line_number": 915,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_create_summary_file",
              "signature": "(self, state, puzzle_path: str, saved_files: Dict[str, str], summary_path: Path)",
              "docstring": "Create a summary file with key information and file locations",
              "line_number": 932,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_create_compressed_archive",
              "signature": "(self, saved_files: Dict[str, str], base_name: str) -> Optional[str]",
              "docstring": "Create a compressed archive of all generated files",
              "line_number": 989,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_extract_key_insights",
              "signature": "(self, state) -> Dict[str, List[str]]",
              "docstring": "Extract and categorize key insights",
              "line_number": 1006,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_find_hex_patterns",
              "signature": "(self, text: str, length: int) -> List[str]",
              "docstring": "Find hex patterns of specific length",
              "line_number": 1034,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_make_safe_filename",
              "signature": "(self, name: str) -> str",
              "docstring": "Make a string safe for use as a filename",
              "line_number": 1040,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": []
        }
      ],
      "constants": [],
      "file_size": 45247,
      "line_count": 1052
    },
    {
      "name": "core.utils",
      "path": "core/utils.py",
      "docstring": "\nUtility functions for the Crypto Hunter application.\n",
      "imports": [
        "import os",
        "import logging",
        "from pathlib import Path",
        "from collections import defaultdict"
      ],
      "functions": [
        {
          "name": "browse_puzzles",
          "signature": "(puzzles_dir)",
          "docstring": "Browse the available puzzles in the directory.",
          "line_number": 10,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "get_puzzle_info",
          "signature": "(puzzle_path)",
          "docstring": "Get information about a puzzle file.",
          "line_number": 30,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "find_clues",
          "signature": "(puzzle_path)",
          "docstring": "\n    Find clues associated with a puzzle.\n    Looks for clues in the 'clues' directory with the same name as the puzzle category.\n\n    Args:\n        puzzle_path: Path to the puzzle file or directory\n\n    Returns:\n        List of clue file paths\n    ",
          "line_number": 57,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "load_clues",
          "signature": "(puzzle_path)",
          "docstring": "\n    Load clues associated with a puzzle.\n\n    Args:\n        puzzle_path: Path to the puzzle file or directory\n\n    Returns:\n        List of clue dictionaries with 'text' and 'file' keys\n    ",
          "line_number": 83,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "find_patterns",
          "signature": "(puzzle_path)",
          "docstring": "\n    Find patterns associated with a puzzle.\n    Looks for patterns in the 'patterns' directory with the same name as the puzzle category,\n    as well as generic patterns that apply to all puzzles.\n\n    Args:\n        puzzle_path: Path to the puzzle file or directory\n\n    Returns:\n        List of pattern file paths\n    ",
          "line_number": 121,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "load_patterns",
          "signature": "(puzzle_path)",
          "docstring": "\n    Load patterns associated with a puzzle.\n\n    Args:\n        puzzle_path: Path to the puzzle file or directory\n\n    Returns:\n        List of pattern dictionaries with 'text', 'file', and 'category' keys\n    ",
          "line_number": 155,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "setup_logging",
          "signature": "(verbose)",
          "docstring": "Set up logging for the application.",
          "line_number": 186,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 5831,
      "line_count": 192
    },
    {
      "name": "core.coding_agent",
      "path": "core/coding_agent.py",
      "docstring": "\nCoding agent adapter for Crypto Hunter.\nProvides an interface to the core/code_agent.py functionality.\n",
      "imports": [
        "import os",
        "import sys",
        "import logging",
        "import importlib",
        "import time",
        "from typing import Dict",
        "from typing import List",
        "from typing import Any",
        "from typing import Optional",
        "from typing import Tuple",
        "from typing import Union",
        "from core.state import State",
        "from core.agent import CryptoAgent",
        "from core.code_agent import CodeAgent",
        "from core.code_agent import DynamicToolRegistry",
        "from core.code_agent import SafeExecutionEnvironment",
        "from core.user_interaction import start_user_interaction",
        "from core.user_interaction import check_for_user_input",
        "from core.user_interaction import process_user_input",
        "from core.user_interaction import register_callback",
        "from core.user_interaction import set_context",
        "from analyzers import get_all_analyzers"
      ],
      "functions": [
        {
          "name": "is_api_key_set",
          "signature": "(key_name: str) -> bool",
          "docstring": "\n    Check if an API key is set in the environment.\n\n    Args:\n        key_name: Name of the environment variable for the API key\n\n    Returns:\n        True if the key is set, False otherwise\n    ",
          "line_number": 764,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [
        {
          "name": "CodingAgent",
          "docstring": "\n    Adapter class to integrate the CodeAgent functionality with the main application.\n    ",
          "line_number": 28,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self, provider: str, api_key: Optional[str], model: Optional[str], verbose: bool)",
              "docstring": "\n        Initialize the coding agent adapter.\n\n        Args:\n            provider: LLM provider to use (anthropic, openai, etc.)\n            api_key: Optional API key (if not provided, will use environment variables)\n            model: Optional model name\n            verbose: Whether to output verbose logs\n        ",
              "line_number": 33,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_should_try_llm_initialization",
              "signature": "(self) -> bool",
              "docstring": "\n        Determine if we should even attempt to initialize LLM-dependent components.\n        This prevents unnecessary API calls when it's clear no API access is available.\n\n        Returns:\n            True if we should try to initialize LLM components, False otherwise\n        ",
              "line_number": 82,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_initialize_llm_agent",
              "signature": "(self) -> Optional[CryptoAgent]",
              "docstring": "\n        Initialize the LLM agent with provider fallback.\n\n        Returns:\n            Initialized CryptoAgent or None if initialization fails\n        ",
              "line_number": 110,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "analyze",
              "signature": "(self, state: State, max_iterations: int) -> State",
              "docstring": "\n        Analyze the puzzle using code generation capabilities.\n\n        Args:\n            state: Current puzzle state\n            max_iterations: Maximum number of analysis iterations\n\n        Returns:\n            Updated state after analysis\n        ",
              "line_number": 150,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_analyze_file",
              "signature": "(self, state: State, filename: str) -> State",
              "docstring": "\n        Analyze a single file using code generation.\n\n        Args:\n            state: Current state containing the file\n            filename: Name of the file to analyze\n\n        Returns:\n            Updated state\n        ",
              "line_number": 354,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_analyze_combined_files",
              "signature": "(self, state: State) -> State",
              "docstring": "\n        Analyze all files together for cross-file patterns.\n\n        Args:\n            state: Current state with multiple files\n\n        Returns:\n            Updated state\n        ",
              "line_number": 431,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_attempt_direct_solution",
              "signature": "(self, state: State) -> State",
              "docstring": "\n        Make a final attempt to directly solve the puzzle.\n\n        Args:\n            state: Current state after other analyses\n\n        Returns:\n            Updated state\n        ",
              "line_number": 501,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_run_fallback_analysis",
              "signature": "(self, state: State) -> State",
              "docstring": "\n        Run fallback analysis when CodeAgent is not available.\n\n        Args:\n            state: Current puzzle state\n\n        Returns:\n            Updated state\n        ",
              "line_number": 554,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_verify_solution",
              "signature": "(self, state: State, solution: str) -> bool",
              "docstring": "\n        Attempt to verify a potential solution.\n\n        Args:\n            state: Current puzzle state\n            solution: Potential solution to verify\n\n        Returns:\n            True if the solution is verified, False otherwise\n        ",
              "line_number": 591,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "generate_code",
              "signature": "(self, task_description: str, state: State) -> str",
              "docstring": "\n        Generate code for a given task description.\n\n        Args:\n            task_description: Description of the task to generate code for\n            state: Current puzzle state\n\n        Returns:\n            Generated code as a string\n        ",
              "line_number": 634,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "execute_code",
              "signature": "(self, code: str, inputs: Dict[str, Any]) -> Dict[str, Any]",
              "docstring": "\n        Execute the generated code with the given inputs.\n\n        Args:\n            code: Code to execute\n            inputs: Dictionary of inputs for the code\n\n        Returns:\n            Dictionary with execution results\n        ",
              "line_number": 675,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_is_text_file",
              "signature": "(self, filename: str, content: bytes) -> bool",
              "docstring": "\n        Determine if a file is likely a text file.\n\n        Args:\n            filename: Name of the file\n            content: Binary content of the file\n\n        Returns:\n            True if likely a text file, False otherwise\n        ",
              "line_number": 733,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": []
        }
      ],
      "constants": [],
      "file_size": 29743,
      "line_count": 774
    },
    {
      "name": "core.arweave_tools_main",
      "path": "core/arweave_tools_main.py",
      "docstring": "\nArweave Puzzle Series Tools Module - Main\n\nThis module imports and combines all the tools from the Arweave Puzzle Series tools modules.\n",
      "imports": [
        "from core.arweave_tools import algebra_solver",
        "from core.arweave_tools import beep_pattern_finder",
        "from core.arweave_tools import riddle_lookup",
        "from core.arweave_tools import coordinate_calculator",
        "from core.arweave_tools_part2 import arweave_fetch",
        "from core.arweave_tools_part2 import steganalysis",
        "from core.arweave_tools_part2 import calculate_entropy",
        "from core.arweave_tools_part2 import extract_lsb",
        "from core.arweave_tools_part2 import is_meaningful_data",
        "from core.arweave_tools_part2 import extract_metadata",
        "from core.arweave_tools_part2 import extract_strings",
        "from core.steganography_tools import extract_image_lsb",
        "from core.steganography_tools import extract_appended_data",
        "from core.steganography_tools import analyze_audio_spectrogram",
        "from core.steganography_tools import analyze_zero_width_chars",
        "from core.steganography_tools import extract_first_letters",
        "from core.steganography_tools import find_embedded_files",
        "from core.steganography_tools import analyze_stego",
        "from core.arweave_tools_part3 import linear_program_solver",
        "from core.arweave_tools_part3 import combinatorics_calculator",
        "from core.arweave_tools_part3 import knowledge_graph_query",
        "from core.arweave_tools_part3 import timeline_analyzer",
        "from core.arweave_tools_part3 import file_type_router",
        "import inspect"
      ],
      "functions": [
        {
          "name": "get_tool",
          "signature": "(tool_name)",
          "docstring": "Get a tool by name.",
          "line_number": 149,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "list_tools",
          "signature": "()",
          "docstring": "List all available tools.",
          "line_number": 153,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "get_tools_by_category",
          "signature": "(category)",
          "docstring": "Get all tools in a specific category.",
          "line_number": 164,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "register_arweave_tools_with_agent",
          "signature": "(code_agent)",
          "docstring": "Register all Arweave tools with the CodeAgent.",
          "line_number": 175,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [
        "ARWEAVE_TOOLS = {'algebra_solver': {'function': algebra_solver, 'description': 'Set up and solve linear systems automatically', 'category': 'Puzzle Weave 1'}, 'beep_pattern_finder': {'function': beep_pattern_finder, 'description': 'Find specific events in time-based patterns', 'category': 'Puzzle Weave 1'}, 'riddle_lookup': {'function': riddle_lookup, 'description': 'Look up common riddles in a database', 'category': 'Puzzle Weave 1'}, 'coordinate_calculator': {'function': coordinate_calculator, 'description': 'Perform calculations on geographic coordinates', 'category': 'Puzzle Weave 1'}, 'arweave_fetch': {'function': arweave_fetch, 'description': 'Fetch transaction data from Arweave', 'category': 'Puzzle Weave 2'}, 'steganalysis': {'function': steganalysis, 'description': 'Analyze files for steganographic content', 'category': 'Puzzle Weave 2'}, 'linear_program_solver': {'function': linear_program_solver, 'description': 'Solve linear programming problems', 'category': 'Puzzle Weave 4'}, 'combinatorics_calculator': {'function': combinatorics_calculator, 'description': 'Calculate combinatorial probabilities', 'category': 'Puzzle Weave 4'}, 'knowledge_graph_query': {'function': knowledge_graph_query, 'description': 'Query a knowledge graph for information', 'category': 'Puzzle Weave 8'}, 'timeline_analyzer': {'function': timeline_analyzer, 'description': 'Analyze timeline of events to find patterns or matches', 'category': 'Puzzle Weave 8'}, 'file_type_router': {'function': file_type_router, 'description': 'Detect file type and route to appropriate analysis pipeline', 'category': 'Puzzle Weave 13'}, 'analyze_stego': {'function': analyze_stego, 'description': 'Comprehensive steganography analysis for various file types', 'category': 'Steganography'}, 'extract_image_lsb': {'function': extract_image_lsb, 'description': 'Extract least significant bits from image data', 'category': 'Steganography'}, 'extract_appended_data': {'function': extract_appended_data, 'description': 'Extract data appended after file EOF markers', 'category': 'Steganography'}, 'analyze_audio_spectrogram': {'function': analyze_audio_spectrogram, 'description': 'Analyze audio file for hidden data in spectrogram', 'category': 'Steganography'}, 'analyze_zero_width_chars': {'function': analyze_zero_width_chars, 'description': 'Analyze text for zero-width characters that might hide data', 'category': 'Steganography'}, 'extract_first_letters': {'function': extract_first_letters, 'description': 'Extract first letters from lines or paragraphs to find hidden messages', 'category': 'Steganography'}, 'find_embedded_files': {'function': find_embedded_files, 'description': 'Find embedded files within binary data', 'category': 'Steganography'}}"
      ],
      "file_size": 6020,
      "line_count": 200
    },
    {
      "name": "core.steganography_extractor",
      "path": "core/steganography_extractor.py",
      "docstring": "\nModule for extracting hidden data from images using steganography techniques.\n",
      "imports": [
        "from PIL import Image",
        "import numpy",
        "import io",
        "from typing import Dict",
        "from typing import List",
        "from typing import Tuple",
        "from typing import Union",
        "from typing import Optional",
        "import os"
      ],
      "functions": [
        {
          "name": "analyze_steganography",
          "signature": "(file_path, image_data, bit_planes, regions)",
          "docstring": "\n    Analyze an image for steganographic content.\n    \n    Args:\n        file_path: Path to the image file (optional if image_data provided)\n        image_data: Raw image data bytes (optional if file_path provided)\n        bit_planes: List of bit planes to analyze (default: [0, 1, 6, 7])\n        regions: List of regions to analyze (default: [\"full\", \"top\", \"bottom\"])\n        \n    Returns:\n        Dictionary with analysis results\n    ",
          "line_number": 10,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "extract_region",
          "signature": "(img_array, region_name)",
          "docstring": "\n    Extract a region from an image array.\n    \n    Args:\n        img_array: Numpy array of the image\n        region_name: Name of the region to extract\n        \n    Returns:\n        Numpy array of the extracted region\n    ",
          "line_number": 102,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "extract_lsb_data",
          "signature": "(img_array, bit_plane)",
          "docstring": "\n    Extract LSB data from an image array.\n    \n    Args:\n        img_array: Numpy array of the image\n        bit_plane: Bit plane to extract (0 = LSB, 1 = second LSB, etc.)\n        \n    Returns:\n        Binary string of extracted data\n    ",
          "line_number": 137,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "check_binary_pattern",
          "signature": "(binary_data)",
          "docstring": "\n    Check for patterns in binary data that might indicate steganography.\n    \n    Args:\n        binary_data: Binary string to analyze\n        \n    Returns:\n        Tuple of (has_pattern, pattern_type)\n    ",
          "line_number": 179,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 7927,
      "line_count": 235
    },
    {
      "name": "core.state",
      "path": "core/state.py",
      "docstring": "\nEnhanced State module for the Crypto Hunter.\nTracks the state of puzzle analysis including insights and transformations.\nImproved handling of extracted text and steganography results.\n",
      "imports": [
        "import os",
        "import time",
        "import mimetypes",
        "import re",
        "import hashlib",
        "from pathlib import Path",
        "from typing import List",
        "from typing import Dict",
        "from typing import Any",
        "from typing import Optional",
        "from typing import Set",
        "from dataclasses import dataclass",
        "from dataclasses import field",
        "from core.logger import solution_logger"
      ],
      "functions": [],
      "classes": [
        {
          "name": "State",
          "docstring": null,
          "line_number": 19,
          "methods": [
            {
              "name": "__post_init__",
              "signature": "(self)",
              "docstring": null,
              "line_number": 41,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "set_puzzle_file",
              "signature": "(self, file_path: str) -> None",
              "docstring": "Set the puzzle file and load its content",
              "line_number": 45,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_load_file",
              "signature": "(self)",
              "docstring": "Load puzzle_file into binary_data or puzzle_text based on type.",
              "line_number": 69,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "add_insight",
              "signature": "(self, text: str, analyzer: str) -> None",
              "docstring": "Add an insight with proper formatting",
              "line_number": 100,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "add_transformation",
              "signature": "(self, name: str, description: str, input_data: Any, output_data: Any, analyzer: str) -> None",
              "docstring": "Add a transformation with enhanced handling of extracted text",
              "line_number": 119,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_should_promote_to_puzzle_text",
              "signature": "(self, name: str, output_data: Any) -> bool",
              "docstring": "Determine if transformation output should be promoted to puzzle_text",
              "line_number": 145,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "set_puzzle_text",
              "signature": "(self, txt: str) -> None",
              "docstring": "Set puzzle text and log the change",
              "line_number": 189,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "set_binary_data",
              "signature": "(self, data: bytes) -> None",
              "docstring": "Store binary data and record insight",
              "line_number": 204,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "set_solution",
              "signature": "(self, sol: str) -> None",
              "docstring": "Record the solution and log it",
              "line_number": 218,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "add_related_file",
              "signature": "(self, filename: str, content: bytes) -> None",
              "docstring": "Add a related file with metadata",
              "line_number": 230,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "add_clue",
              "signature": "(self, text: str, source: str) -> None",
              "docstring": "Add a clue with source information",
              "line_number": 256,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "add_pattern",
              "signature": "(self, text: str, source: str, category: str) -> None",
              "docstring": "Add a pattern from similar puzzles",
              "line_number": 265,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_is_likely_text",
              "signature": "(self, data: bytes) -> bool",
              "docstring": "Check if binary data is likely to be text",
              "line_number": 275,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_infer_puzzle_type",
              "signature": "(self) -> None",
              "docstring": "Try to infer the puzzle type from available data",
              "line_number": 288,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "is_binary",
              "signature": "(self) -> bool",
              "docstring": "Check if state contains binary data",
              "line_number": 311,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "is_text",
              "signature": "(self) -> bool",
              "docstring": "Check if state contains text data",
              "line_number": 315,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "is_binary_file",
              "signature": "(self, file_path) -> bool",
              "docstring": "Check if a file is likely binary",
              "line_number": 319,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_summary",
              "signature": "(self) -> str",
              "docstring": "Get a comprehensive summary of the current state",
              "line_number": 328,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_content_sample",
              "signature": "(self, max_size: int, max_binary_size: int) -> str",
              "docstring": "Get a sample of the puzzle content for analysis",
              "line_number": 373,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "merge_related_state",
              "signature": "(self, other_state: 'State') -> None",
              "docstring": "Merge insights and transformations from another state",
              "line_number": 391,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "to_dict",
              "signature": "(self) -> Dict[str, Any]",
              "docstring": "Convert state to dictionary for serialization",
              "line_number": 414,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "__str__",
              "signature": "(self) -> str",
              "docstring": "String representation of the state",
              "line_number": 441,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": [
            "dataclass"
          ]
        }
      ],
      "constants": [],
      "file_size": 16199,
      "line_count": 443
    },
    {
      "name": "core.arweave_tools_part3",
      "path": "core/arweave_tools_part3.py",
      "docstring": "\nArweave Puzzle Series Tools Module - Part 3\n\nThis module provides specialized tools for solving puzzles in the Arweave Puzzle Series.\nEach tool implements one of the orchestrated solution pointers described in the series pattern.\n",
      "imports": [
        "import math",
        "import itertools",
        "import numpy",
        "from typing import Dict",
        "from typing import List",
        "from typing import Any",
        "from typing import Optional",
        "from typing import Tuple",
        "from typing import Union",
        "from scipy import optimize",
        "from datetime import datetime",
        "import json"
      ],
      "functions": [
        {
          "name": "linear_program_solver",
          "signature": "(objective: List[float], constraints_lhs: List[List[float]], constraints_rhs: List[float], bounds: List[Tuple[float, float]], maximize: bool) -> Dict[str, Any]",
          "docstring": "\n    Solve linear programming problems.\n\n    Args:\n        objective: Coefficients of the objective function\n        constraints_lhs: Left-hand side coefficients of constraints\n        constraints_rhs: Right-hand side values of constraints\n        bounds: Bounds for each variable (min, max)\n        maximize: Whether to maximize (True) or minimize (False)\n\n    Returns:\n        Dictionary with the results\n    ",
          "line_number": 16,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "combinatorics_calculator",
          "signature": "(problem_type: str, parameters: Dict[str, Any]) -> Dict[str, Any]",
          "docstring": "\n    Calculate combinatorial probabilities.\n\n    Args:\n        problem_type: Type of combinatorial problem\n        parameters: Parameters specific to the problem type\n\n    Returns:\n        Dictionary with the results\n    ",
          "line_number": 68,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "knowledge_graph_query",
          "signature": "(query_text: str, domain: str) -> Dict[str, Any]",
          "docstring": "\n    Query a knowledge graph for information.\n\n    Args:\n        query_text: The query text\n        domain: Domain to search in (arweave, history, etc.)\n\n    Returns:\n        Dictionary with the results\n    ",
          "line_number": 144,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "timeline_analyzer",
          "signature": "(events: List[Dict[str, str]], query: str) -> Dict[str, Any]",
          "docstring": "\n    Analyze timeline of events to find patterns or matches.\n\n    Args:\n        events: List of event dictionaries with date and description\n        query: Optional query to match against the timeline\n\n    Returns:\n        Dictionary with the results\n    ",
          "line_number": 222,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "file_type_router",
          "signature": "(data: bytes) -> Dict[str, Any]",
          "docstring": "\n    Detect file type and route to appropriate analysis pipeline.\n\n    Args:\n        data: Binary data to analyze\n\n    Returns:\n        Dictionary with the results\n    ",
          "line_number": 310,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 14849,
      "line_count": 424
    },
    {
      "name": "core.arweave_tools",
      "path": "core/arweave_tools.py",
      "docstring": "\nArweave Puzzle Series Tools Module\n\nThis module provides specialized tools for solving puzzles in the Arweave Puzzle Series.\nEach tool implements one of the orchestrated solution pointers described in the series pattern.\n",
      "imports": [
        "import re",
        "import math",
        "import json",
        "import base64",
        "import hashlib",
        "import itertools",
        "import numpy",
        "from typing import Dict",
        "from typing import List",
        "from typing import Any",
        "from typing import Optional",
        "from typing import Tuple",
        "from typing import Union",
        "from collections import Counter",
        "from datetime import datetime",
        "from datetime import timedelta",
        "from scipy import optimize"
      ],
      "functions": [
        {
          "name": "algebra_solver",
          "signature": "(equations: List[str], variables: List[str]) -> Dict[str, Any]",
          "docstring": "\n    Set up and solve linear systems automatically.\n    \n    Args:\n        equations: List of equation strings (e.g., [\"x + y = 12\", \"x - y = 2\"])\n        variables: List of variable names to solve for (e.g., [\"x\", \"y\"])\n    \n    Returns:\n        Dictionary with the results\n    ",
          "line_number": 22,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "beep_pattern_finder",
          "signature": "(start_time: str, interval: int, pattern_description: str, target_count: int) -> Dict[str, Any]",
          "docstring": "\n    Find specific events in time-based patterns.\n    \n    Args:\n        start_time: Starting time in HH:MM format\n        interval: Base interval in seconds\n        pattern_description: Description of the pattern (e.g., \"every minute, beep at seconds 0, 15, 30, 45\")\n        target_count: Which occurrence to find (e.g., 99th beep)\n    \n    Returns:\n        Dictionary with the results\n    ",
          "line_number": 87,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "riddle_lookup",
          "signature": "(riddle_text: str) -> Dict[str, Any]",
          "docstring": "\n    Look up common riddles in a database.\n    \n    Args:\n        riddle_text: The riddle to look up\n    \n    Returns:\n        Dictionary with possible answers\n    ",
          "line_number": 165,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "coordinate_calculator",
          "signature": "(lat: float, lon: float, operation: str) -> Dict[str, Any]",
          "docstring": "\n    Perform calculations on geographic coordinates.\n    \n    Args:\n        lat: Latitude value\n        lon: Longitude value\n        operation: Type of calculation to perform (difference, sum, etc.)\n    \n    Returns:\n        Dictionary with the results\n    ",
          "line_number": 265,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 12095,
      "line_count": 317
    },
    {
      "name": "core.web_agent",
      "path": "core/web_agent.py",
      "docstring": "\nWeb browsing agent for Crypto Hunter.\nAllows the agent to search the web and analyze online information.\n",
      "imports": [
        "import os",
        "import requests",
        "from urllib.parse import urlparse",
        "from urllib.parse import urljoin",
        "from bs4 import BeautifulSoup",
        "import re",
        "from typing import List",
        "from typing import Dict",
        "from typing import Any",
        "from typing import Optional",
        "from typing import Union",
        "import time",
        "import logging"
      ],
      "functions": [],
      "classes": [
        {
          "name": "WebAgent",
          "docstring": "\n    Agent capable of browsing the web to gather information for puzzle solving.\n    ",
          "line_number": 19,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self, user_agent, rate_limit, max_pages, timeout, proxies)",
              "docstring": "\n        Initialize the WebAgent.\n        \n        Args:\n            user_agent: Browser user agent string\n            rate_limit: Time in seconds between requests\n            max_pages: Maximum number of pages to visit\n            timeout: Request timeout in seconds\n            proxies: Optional proxy configuration\n        ",
              "line_number": 23,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "fetch_url",
              "signature": "(self, url: str) -> Optional[str]",
              "docstring": "\n        Fetch the content of a URL.\n        \n        Args:\n            url: URL to fetch\n            \n        Returns:\n            HTML content or None if failed\n        ",
              "line_number": 49,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "search",
              "signature": "(self, query: str, search_engine, num_results) -> List[Dict[str, str]]",
              "docstring": "\n        Perform a web search.\n        \n        Args:\n            query: Search query\n            search_engine: Search engine URL\n            num_results: Maximum number of results to return\n            \n        Returns:\n            List of search results (title, url, snippet)\n        ",
              "line_number": 78,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "extract_text",
              "signature": "(self, html: str) -> str",
              "docstring": "\n        Extract readable text from HTML.\n        \n        Args:\n            html: HTML content\n            \n        Returns:\n            Extracted text\n        ",
              "line_number": 139,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "crawl",
              "signature": "(self, start_url: str, depth, keywords) -> Dict[str, Any]",
              "docstring": "\n        Crawl a website to gather information.\n        \n        Args:\n            start_url: Starting URL\n            depth: Maximum crawl depth\n            keywords: Optional list of keywords to look for\n            \n        Returns:\n            Dictionary with crawl results\n        ",
              "line_number": 172,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "analyze_cryptographic_information",
              "signature": "(self, query: str) -> Dict[str, Any]",
              "docstring": "\n        Search and analyze information related to a cryptographic puzzle.\n        \n        Args:\n            query: Search query related to the puzzle\n            \n        Returns:\n            Analysis results\n        ",
              "line_number": 244,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "integrate_with_state",
              "signature": "(self, state, query: str) -> Any",
              "docstring": "\n        Integrate web browsing results with the puzzle state.\n        \n        Args:\n            state: Current puzzle state\n            query: Search query\n            \n        Returns:\n            Updated state\n        ",
              "line_number": 327,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": []
        }
      ],
      "constants": [],
      "file_size": 12901,
      "line_count": 368
    },
    {
      "name": "core.agent",
      "path": "core/agent.py",
      "docstring": "\nCrypto Hunter Agent Module\nHandles the interaction with LLM providers and coordinates the analysis.\n",
      "imports": [
        "import os",
        "import json",
        "import textwrap",
        "import time",
        "from typing import List",
        "from typing import Dict",
        "from typing import Optional",
        "from typing import Any",
        "from typing import Union",
        "from langchain_core.prompts import PromptTemplate",
        "from langchain_core.runnables import RunnablePassthrough",
        "from langchain_core.runnables import RunnableSequence",
        "from langchain_openai import ChatOpenAI",
        "from langchain_community.chat_models import ChatAnthropic",
        "from langchain_core.messages import BaseMessage",
        "from langchain_community.llms import HuggingFaceEndpoint",
        "from core.state import State",
        "from core.prompts import STATE_ASSESSMENT_PROMPT",
        "from core.prompts import STRATEGY_SELECTION_PROMPT",
        "from core.prompts import DIRECT_SOLUTION_PROMPT",
        "from core.prompts import FALLBACK_STATE_ASSESSMENT_TEXT",
        "from core.prompts import FALLBACK_STRATEGY_SELECTION_TEXT",
        "from core.prompts import FALLBACK_DIRECT_SOLUTION_TEXT",
        "from dotenv import load_dotenv",
        "from core.logger import solution_logger",
        "from core.logger import solution_logger",
        "from core.user_interaction import start_user_interaction",
        "from core.user_interaction import check_for_user_input",
        "from core.user_interaction import process_user_input",
        "from core.user_interaction import register_callback",
        "from core.user_interaction import set_context",
        "from analyzers import get_all_analyzers",
        "from analyzers import get_analyzer",
        "from analyzers import get_compatible_analyzers",
        "from anthropic import Anthropic",
        "from analyzers import get_analyzer",
        "from openai import OpenAI",
        "from analyzers import get_analyzer",
        "from analyzers import get_analyzer",
        "from analyzers import get_analyzer",
        "from analyzers import get_analyzer",
        "from analyzers import get_analyzer",
        "from analyzers import get_analyzer",
        "from analyzers import get_analyzer",
        "from analyzers import get_analyzer",
        "from analyzers import get_analyzer"
      ],
      "functions": [],
      "classes": [
        {
          "name": "CryptoAgent",
          "docstring": "\n    Agent responsible for analyzing cryptographic puzzles using LLMs.\n    ",
          "line_number": 27,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self, provider, api_key, model, verbose)",
              "docstring": "\n        Initialize the agent with the specified provider.\n\n        Args:\n            provider: LLM provider to use (anthropic, openai, huggingface, or local)\n            api_key: Optional API key (if not provided, will use environment variables)\n            model: Optional model name (specific to the provider)\n            verbose: Whether to output detailed logs\n        ",
              "line_number": 31,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_should_try_llm_initialization",
              "signature": "(self) -> bool",
              "docstring": "\n        Determine if we should even attempt to initialize LLM-dependent components.\n        This prevents unnecessary API calls when it's clear no API access is available.\n\n        Returns:\n            True if we should try to initialize LLM components, False otherwise\n        ",
              "line_number": 97,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_test_api_access",
              "signature": "(self)",
              "docstring": "Test if the API key is valid.",
              "line_number": 125,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_initialize_llm",
              "signature": "(self)",
              "docstring": "\n        Initialize the LLM based on the provider.\n        Returns the LLM or None if initialization fails.\n        ",
              "line_number": 184,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_create_state_assessment_chain",
              "signature": "(self)",
              "docstring": "Create the chain for assessing the puzzle state.",
              "line_number": 261,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_create_strategy_chain",
              "signature": "(self)",
              "docstring": "Create the chain for selecting analysis strategies.",
              "line_number": 274,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_create_direct_solution_chain",
              "signature": "(self)",
              "docstring": "Create the chain for attempting direct solutions.",
              "line_number": 287,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_fallback_assessment",
              "signature": "(self, state)",
              "docstring": "\n        Provide a basic assessment of the puzzle when in fallback mode.\n        ",
              "line_number": 300,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_fallback_strategy",
              "signature": "(self, state)",
              "docstring": "\n        Provide basic strategy recommendations when in fallback mode.\n        ",
              "line_number": 309,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_fallback_direct_solution",
              "signature": "(self, state)",
              "docstring": "\n        Attempt basic solution approaches when in fallback mode.\n        ",
              "line_number": 315,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_handle_realtime_finding",
              "signature": "(self, finding_type: str, analyzer: str, content: str) -> None",
              "docstring": "\n        Handle a real-time finding from an analyzer.\n\n        Args:\n            finding_type: Type of finding (insight or transformation)\n            analyzer: Name of the analyzer that generated the finding\n            content: Content of the finding\n        ",
              "line_number": 321,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_send_realtime_findings_to_llm",
              "signature": "(self) -> None",
              "docstring": "\n        Send real-time findings to the LLM.\n        ",
              "line_number": 342,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_send_to_llm_without_response",
              "signature": "(self, prompt: str) -> None",
              "docstring": "\n        Send a prompt to the LLM without expecting a response.\n\n        Args:\n            prompt: Text prompt to send\n        ",
              "line_number": 372,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_send_to_llm",
              "signature": "(self, prompt)",
              "docstring": "\n        Safely send a prompt to the LLM.\n\n        Args:\n            prompt: Text prompt to send\n\n        Returns:\n            Response text or None if failed\n        ",
              "line_number": 395,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "analyze",
              "signature": "(self, state: State, max_iterations: int) -> State",
              "docstring": "\n        Analyze the puzzle and attempt to solve it.\n\n        The analysis process includes multiple strategies with enhanced LLM orchestration:\n        1. Using LLM to assess the state and select appropriate analyzers\n        2. Executing selected analyzers to gain insights\n        3. LLM reviews results and decides next steps dynamically\n        4. LLM can pass information between analyzers and create feedback loops\n        5. Using code-based analysis when other approaches fail or get stuck\n        6. Attempting direct solution as a last resort\n\n        The LLM acts as the central orchestrator, making decisions at each step\n        and steering the entire analysis process with continuous feedback loops.\n\n        Findings from analyzers are fed back to the LLM in real-time to provide\n        continuous feedback during the analysis process.\n\n        Args:\n            state: The current puzzle state\n            max_iterations: Maximum number of analysis iterations\n\n        Returns:\n            Updated puzzle state\n        ",
              "line_number": 437,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_assess_state",
              "signature": "(self, state: State) -> str",
              "docstring": "\n        Assess the current state of the puzzle.\n        ",
              "line_number": 1121,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_select_strategy",
              "signature": "(self, state: State, assessment: str, previous_results: str) -> Dict",
              "docstring": "\n        Select the next analysis strategy based on the current state.\n\n        Args:\n            state: Current puzzle state\n            assessment: Assessment of the current state\n            previous_results: Optional results from previous analyzer runs\n\n        Returns:\n            Dictionary with strategy information\n        ",
              "line_number": 1189,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_review_analyzer_results",
              "signature": "(self, state: State, analyzer_name: str, previous_insights_count: int, previous_transformations_count: int) -> Dict",
              "docstring": "\n        Review the results of an analyzer run and decide what to do next.\n\n        Args:\n            state: Current puzzle state\n            analyzer_name: Name of the analyzer that was just run\n            previous_insights_count: Number of insights before the analyzer was run\n            previous_transformations_count: Number of transformations before the analyzer was run\n\n        Returns:\n            Dictionary with review information and next steps\n        ",
              "line_number": 1287,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_attempt_direct_solution",
              "signature": "(self, state: State) -> None",
              "docstring": "\n        Attempt to directly solve the puzzle without further analysis.\n        ",
              "line_number": 1396,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": []
        }
      ],
      "constants": [],
      "file_size": 72348,
      "line_count": 1460
    },
    {
      "name": "core.arweave_tools_part2",
      "path": "core/arweave_tools_part2.py",
      "docstring": "\nArweave Puzzle Series Tools Module - Part 2\n\nThis module provides specialized tools for solving puzzles in the Arweave Puzzle Series.\nEach tool implements one of the orchestrated solution pointers described in the series pattern.\n",
      "imports": [
        "import re",
        "import math",
        "import json",
        "import base64",
        "import hashlib",
        "from typing import Dict",
        "from typing import List",
        "from typing import Any",
        "from typing import Optional",
        "from typing import Tuple",
        "from typing import Union",
        "import requests"
      ],
      "functions": [
        {
          "name": "arweave_fetch",
          "signature": "(tx_id: str, gateway: str) -> Dict[str, Any]",
          "docstring": "\n    Fetch transaction data from Arweave.\n    \n    Args:\n        tx_id: Transaction ID\n        gateway: Arweave gateway to use\n    \n    Returns:\n        Dictionary with the transaction data\n    ",
          "line_number": 17,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "steganalysis",
          "signature": "(data: bytes, method: str) -> Dict[str, Any]",
          "docstring": "\n    Analyze files for steganographic content.\n    \n    Args:\n        data: Binary data to analyze\n        method: Steganography detection method\n    \n    Returns:\n        Dictionary with the results\n    ",
          "line_number": 62,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "calculate_entropy",
          "signature": "(data: bytes) -> float",
          "docstring": "Calculate Shannon entropy of data.",
          "line_number": 129,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "extract_lsb",
          "signature": "(data: bytes, file_type: str) -> Optional[bytes]",
          "docstring": "Extract least significant bits from image data.",
          "line_number": 142,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "is_meaningful_data",
          "signature": "(data: Optional[bytes]) -> bool",
          "docstring": "Check if data appears to be meaningful rather than random.",
          "line_number": 164,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "extract_metadata",
          "signature": "(data: bytes, file_type: str) -> Dict[str, Any]",
          "docstring": "Extract metadata from file.",
          "line_number": 182,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "extract_strings",
          "signature": "(data: bytes, min_length: int) -> List[str]",
          "docstring": "Extract printable strings from binary data.",
          "line_number": 203,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 6707,
      "line_count": 220
    },
    {
      "name": "core.user_interaction",
      "path": "core/user_interaction.py",
      "docstring": "\nUser Interaction Module\nProvides functionality for handling user input during agent processing.\n",
      "imports": [
        "import threading",
        "import queue",
        "import time",
        "import sys",
        "import select",
        "import os",
        "import signal",
        "from typing import Optional",
        "from typing import Callable",
        "from typing import Dict",
        "from typing import Any",
        "from typing import List",
        "from rich.console import Console",
        "from rich.prompt import Prompt"
      ],
      "functions": [
        {
          "name": "start_user_interaction",
          "signature": "()",
          "docstring": "Start the user interaction handler.",
          "line_number": 176,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "stop_user_interaction",
          "signature": "()",
          "docstring": "Stop the user interaction handler.",
          "line_number": 180,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "check_for_user_input",
          "signature": "() -> Optional[str]",
          "docstring": "\n    Check if there's any user input available.\n\n    Returns:\n        User input string if available, None otherwise\n    ",
          "line_number": 184,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "process_user_input",
          "signature": "(user_input: str, context: Dict[str, Any]) -> Dict[str, Any]",
          "docstring": "\n    Process user input and return a response.\n\n    Args:\n        user_input: The user input to process\n        context: Current context information\n\n    Returns:\n        Updated context with response information\n    ",
          "line_number": 193,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "register_callback",
          "signature": "(name: str, callback: Callable)",
          "docstring": "\n    Register a callback function.\n\n    Args:\n        name: Name of the callback\n        callback: Callback function\n    ",
          "line_number": 210,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "set_context",
          "signature": "(context: Dict[str, Any])",
          "docstring": "\n    Set the current context.\n\n    Args:\n        context: Context information\n    ",
          "line_number": 220,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [
        {
          "name": "UserInteractionHandler",
          "docstring": "\n    Handles user interaction during agent processing.\n    Allows users to interrupt and interact with the agent at any time.\n    ",
          "line_number": 23,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self)",
              "docstring": "Initialize the user interaction handler.",
              "line_number": 29,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "start_listening",
              "signature": "(self)",
              "docstring": "Start listening for user input in a separate thread.",
              "line_number": 38,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "stop_listening",
              "signature": "(self)",
              "docstring": "Stop listening for user input.",
              "line_number": 48,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_input_listener",
              "signature": "(self)",
              "docstring": "Thread function that listens for user input.\n\n        This method keeps the thread alive but doesn't actively prompt for input.\n        ",
              "line_number": 55,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "check_for_input",
              "signature": "(self) -> Optional[str]",
              "docstring": "\n        Check if there's any user input available.\n        This checks the global user_input_buffer.\n\n        Returns:\n            User input string if available, None otherwise\n        ",
              "line_number": 64,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "process_input",
              "signature": "(self, user_input: str, context: Dict[str, Any]) -> Dict[str, Any]",
              "docstring": "\n        Process user input and return a response.\n\n        Args:\n            user_input: The user input to process\n            context: Current context information\n\n        Returns:\n            Updated context with response information\n        ",
              "line_number": 78,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_handle_help_command",
              "signature": "(self) -> Dict[str, Any]",
              "docstring": "Handle the help command.",
              "line_number": 119,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_handle_status_command",
              "signature": "(self) -> Dict[str, Any]",
              "docstring": "Handle the status command.",
              "line_number": 132,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "register_callback",
              "signature": "(self, name: str, callback: Callable)",
              "docstring": "\n        Register a callback function.\n\n        Args:\n            name: Name of the callback\n            callback: Callback function\n        ",
              "line_number": 154,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "set_context",
              "signature": "(self, context: Dict[str, Any])",
              "docstring": "\n        Set the current context.\n\n        Args:\n            context: Context information\n        ",
              "line_number": 164,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": []
        }
      ],
      "constants": [],
      "file_size": 7115,
      "line_count": 227
    },
    {
      "name": "core.prompts",
      "path": "core/prompts.py",
      "docstring": "\nPrompts used for the Crypto Hunter agent.\n",
      "imports": [],
      "functions": [],
      "classes": [],
      "constants": [
        "STATE_ASSESSMENT_PROMPT = '\\nYou are the orchestrator for a cryptographic puzzle solving system.\\nGiven the information below, provide a comprehensive assessment of the puzzle state.\\n\\nCurrent state summary:\\n{state_summary}\\n\\nTransformations applied:\\n{transformations}\\n\\nInsights gathered:\\n{insights}\\n\\nPatterns from similar puzzles:\\n{patterns}\\n\\nSample of puzzle content:\\n{puzzle_content}\\n\\nYour task is to:\\n1. Identify the likely type of cryptographic challenge\\n2. Assess how close we are to a solution\\n3. Note any patterns or clues you can observe\\n4. Consider how patterns from similar puzzles might apply to this one\\n5. Evaluate which approaches have been most promising so far\\n6. Identify any potential connections between different insights\\n7. Suggest what might be the next step to solve this\\n\\nAs the orchestrator, your assessment will guide the entire analysis process.\\nThink holistically about all the information available and how different analyzers might work together.\\nConsider both the technical aspects of the puzzle and the strategic approach to solving it.\\n\\nProvide a detailed but concise assessment:\\n'",
        "STRATEGY_SELECTION_PROMPT = '\\nYou are the orchestrator for a cryptographic puzzle solving system.\\nBased on the current state, assessment, and previous results, determine the best strategy to proceed.\\n\\nCurrent state summary:\\n{state_summary}\\n\\nAssessment:\\n{assessment}\\n\\nTransformations applied:\\n{transformations}\\n\\nInsights gathered:\\n{insights}\\n\\nPatterns from similar puzzles:\\n{patterns}\\n\\nPrevious analyzer results:\\n{previous_results}\\n\\nPrevious chat history:\\n{chat_history}\\n\\nYour task is to select the next analysis strategy. \\nAs the orchestrator, you have full control over the analysis process and can make dynamic decisions.\\nConsider how patterns from similar puzzles might inform your strategy selection.\\nLook for techniques that worked in similar puzzles and apply them to this one.\\nReview previous analyzer results to avoid repeating unsuccessful approaches and to build on successful ones.\\n\\nReturn your answer in this format:\\n\\n```json\\n{{\\n  \"strategy\": \"Brief description of the strategy\",\\n  \"analyzer\": \"name_of_analyzer_to_use\",\\n  \"params\": {{\\n    \"param1\": \"value1\",\\n    \"param2\": \"value2\"\\n  }},\\n  \"reasoning\": \"Explanation of why this strategy was chosen\"\\n}}\\n```\\n\\nAvailable analyzers (ONLY use analyzers from this list):\\n- text_analyzer: For analyzing text patterns and encodings\\n- binary_analyzer: For analyzing binary data\\n- image_analyzer: For analyzing images (steganography)\\n- cipher_analyzer: For detecting and solving classical ciphers (params: cipher_type, input_data)\\n- encoding_analyzer: For detecting and decoding various encodings\\n- blockchain_analyzer: For analyzing crypto addresses and data\\n- crypto_analyzer: For analyzing cryptographic elements including hashes, keys, and signatures\\n- code_analyzer: For generating and executing Python code to solve the puzzle\\n- vision_analyzer: For analyzing images using computer vision techniques\\n- web_analyzer: For analyzing web-related content and URLs\\n\\nIMPORTANT: Do NOT suggest analyzers that are not in the above list. If you need functionality that isn\\'t covered by these analyzers, use code_analyzer to generate custom code instead.\\n\\nThink step by step and choose the most promising approach. You can also suggest running multiple analyzers in sequence if that makes sense.\\n'",
        "DIRECT_SOLUTION_PROMPT = '\\nYou are the orchestrator for a cryptographic puzzle solving system.\\nAfter coordinating multiple analysis steps, you\\'re now attempting to directly solve this puzzle.\\nReview all information gathered and provide your best solution attempt.\\n\\nCurrent state summary:\\n{state_summary}\\n\\nPatterns from similar puzzles:\\n{patterns}\\n\\nPuzzle content:\\n{puzzle_content}\\n\\nAs the orchestrator, you have access to all insights and transformations that have been gathered.\\nSynthesize all this information to attempt a direct solution.\\n\\nConsider:\\n1. Connections between different insights that might not have been noticed before\\n2. Combinations of transformations that might reveal hidden patterns\\n3. Techniques from similar puzzles that might apply here\\n4. Alternative interpretations of the puzzle content\\n5. Insights that seemed minor but might be crucial when combined with others\\n\\nIf you can determine a solution, clearly mark it with \"SOLUTION:\" at the beginning of that line.\\n\\nIf you need more analysis, suggest specific analyzers to run with specific parameters.\\n\\nYour solution attempt:\\n'",
        "FALLBACK_STATE_ASSESSMENT_TEXT = \"\\nThis appears to be a {file_type} file of {file_size} bytes. Without LLM assistance, \\nI'll try to apply basic cryptographic analysis techniques. This might include checking \\nfor common encodings, ciphers, or steganography techniques depending on the file type.\\n\"",
        "FALLBACK_STRATEGY_SELECTION_TEXT = \"\\nSince I'm operating in fallback mode without LLM assistance, I'll apply a sequence of \\nstandard analyzers to attempt to decode or extract information from this puzzle. This \\nincludes checking for common encodings (Base64, Hex), simple substitution ciphers, \\nand file-specific analysis based on the file type.\\n\"",
        "FALLBACK_DIRECT_SOLUTION_TEXT = \"\\nWithout LLM assistance, I've applied basic analysis techniques. For text puzzles, \\nconsider common techniques like: Caesar cipher, ROT13, Base64, Hex encoding, Binary \\nencoding, or ASCII representation. For images, check for steganography using tools \\nlike steghide or examine metadata. For binary files, analyze file signatures and \\nstructures using hexdump. Also consider patterns from similar puzzles that might \\nprovide insights into techniques that worked in similar situations.\\n\""
      ],
      "file_size": 5965,
      "line_count": 157
    },
    {
      "name": "core.code_agent",
      "path": "core/code_agent.py",
      "docstring": "\nCodeAgent for Crypto Hunter.\nAn agent capable of writing and executing its own code to solve puzzles.\n",
      "imports": [
        "import ast",
        "import importlib",
        "import inspect",
        "import json",
        "import logging",
        "import os",
        "import re",
        "import subprocess",
        "import sys",
        "import tempfile",
        "import time",
        "import traceback",
        "import uuid",
        "from pathlib import Path",
        "from typing import Any",
        "from typing import Callable",
        "from typing import Dict",
        "from typing import List",
        "from typing import Optional",
        "from typing import Union",
        "from core.arweave_tools_main import register_arweave_tools_with_agent"
      ],
      "functions": [],
      "classes": [
        {
          "name": "DynamicToolRegistry",
          "docstring": "Registry for dynamically created tools.",
          "line_number": 27,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self, tools_dir: Union[str, Path]) -> None",
              "docstring": "\n        Initialize the tool registry.\n\n        Args:\n            tools_dir: Directory to store dynamically created tools\n        ",
              "line_number": 30,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_load_existing_tools",
              "signature": "(self) -> None",
              "docstring": "Load existing tools from the tools directory.",
              "line_number": 48,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "register_tool",
              "signature": "(self, code: str, name: Optional[str], description: str) -> Optional[str]",
              "docstring": "\n        Register a new tool from code.\n\n        Args:\n            code: Python code for the tool\n            name: Optional name for the tool (extracted from code if not provided)\n            description: Optional description of the tool\n\n        Returns:\n            Tool ID if successful, None otherwise\n        ",
              "line_number": 76,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_tool",
              "signature": "(self, tool_id: str) -> Optional[Callable]",
              "docstring": "Get a tool by ID.",
              "line_number": 156,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "list_tools",
              "signature": "(self) -> List[Dict[str, Any]]",
              "docstring": "List all registered tools.",
              "line_number": 160,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "remove_tool",
              "signature": "(self, tool_id: str) -> bool",
              "docstring": "Remove a tool by ID.",
              "line_number": 172,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": []
        },
        {
          "name": "SafeExecutionEnvironment",
          "docstring": "\n    Provides a safe environment for executing generated code.\n    ",
          "line_number": 187,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self, allowed_modules: Optional[List[str]], max_execution_time: int, memory_limit: int) -> None",
              "docstring": "\n        Initialize the safe execution environment.\n\n        Args:\n            allowed_modules: List of allowed modules (None for default safe set)\n            max_execution_time: Maximum execution time in seconds\n            memory_limit: Memory limit in bytes\n        ",
              "line_number": 192,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_indent_code",
              "signature": "(self, code: str, spaces: int) -> str",
              "docstring": "\n        Indent each line of code by the specified number of spaces.\n\n        Args:\n            code: The code to indent\n            spaces: Number of spaces to indent by\n\n        Returns:\n            Indented code\n        ",
              "line_number": 225,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_create_safe_globals",
              "signature": "(self) -> Dict[str, Any]",
              "docstring": "Create a safe globals dictionary.",
              "line_number": 241,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "execute",
              "signature": "(self, code: str, inputs: Optional[Dict[str, Any]]) -> Dict[str, Any]",
              "docstring": "\n        Execute code in a safe environment.\n\n        Args:\n            code: Python code to execute\n            inputs: Optional dictionary of input variables\n\n        Returns:\n            Dictionary containing execution result\n        ",
              "line_number": 307,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": []
        },
        {
          "name": "CodeAgent",
          "docstring": "\n    Agent capable of writing and executing its own code to solve puzzles.\n    ",
          "line_number": 441,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self, llm_agent: Optional[Any], tools_dir: Union[str, Path], max_execution_time: int, memory_limit: int) -> None",
              "docstring": "\n        Initialize the CodeAgent.\n\n        Args:\n            llm_agent: LLM agent for code generation\n            tools_dir: Directory to store dynamically created tools\n            max_execution_time: Maximum execution time in seconds\n            memory_limit: Memory limit in bytes\n        ",
              "line_number": 446,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "generate_code",
              "signature": "(self, task_description: str, state: Optional[Any], required_outputs: Optional[List[str]]) -> str",
              "docstring": "\n        Generate code for a specific task.\n\n        Args:\n            task_description: Description of the task\n            state: Current puzzle state (if available)\n            required_outputs: List of required output variables\n\n        Returns:\n            Generated code\n        ",
              "line_number": 469,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_generate_fallback_code",
              "signature": "(self, task_description: str, required_outputs: Optional[List[str]]) -> str",
              "docstring": "\n        Generate fallback code templates for common tasks.\n\n        Args:\n            task_description: Description of the task\n            required_outputs: List of required output variables\n\n        Returns:\n            Template code\n        ",
              "line_number": 536,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_template_base64_tool",
              "signature": "(self, required_outputs: Optional[List[str]]) -> str",
              "docstring": "Create a template for base64 encoding/decoding.",
              "line_number": 561,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_template_xor_tool",
              "signature": "(self, required_outputs: Optional[List[str]]) -> str",
              "docstring": "Create a template for XOR cipher.",
              "line_number": 595,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_template_caesar_tool",
              "signature": "(self, required_outputs: Optional[List[str]]) -> str",
              "docstring": "Create a template for Caesar cipher.",
              "line_number": 630,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_template_hash_tool",
              "signature": "(self, required_outputs: Optional[List[str]]) -> str",
              "docstring": "Create a template for hash functions.",
              "line_number": 676,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_template_frequency_analysis_tool",
              "signature": "(self, required_outputs: Optional[List[str]]) -> str",
              "docstring": "Create a template for frequency analysis.",
              "line_number": 718,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_template_generic_analysis_tool",
              "signature": "(self, required_outputs: Optional[List[str]]) -> str",
              "docstring": "Create a template for generic text analysis.",
              "line_number": 767,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "execute_code",
              "signature": "(self, code: str, inputs: Optional[Dict[str, Any]]) -> Dict[str, Any]",
              "docstring": "\n        Execute the generated code safely.\n\n        Args:\n            code: Python code to execute\n            inputs: Optional dictionary of input variables\n\n        Returns:\n            Execution results\n        ",
              "line_number": 848,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "register_new_tool",
              "signature": "(self, task_description: str, state: Optional[Any]) -> Optional[str]",
              "docstring": "\n        Generate and register a new tool based on the task description.\n\n        Args:\n            task_description: Description of the tool to create\n            state: Current puzzle state (if available)\n\n        Returns:\n            Tool ID if successful, None otherwise\n        ",
              "line_number": 861,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "use_tool",
              "signature": "(self, tool_id: str, inputs: Optional[Dict[str, Any]]) -> Dict[str, Any]",
              "docstring": "\n        Use a registered tool.\n\n        Args:\n            tool_id: ID of the tool to use\n            inputs: Input parameters for the tool\n\n        Returns:\n            Tool execution results\n        ",
              "line_number": 879,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "analyze_and_create_tools",
              "signature": "(self, state: Any) -> List[str]",
              "docstring": "\n        Analyze the puzzle state and create appropriate tools.\n\n        Args:\n            state: Current puzzle state\n\n        Returns:\n            List of created tool IDs\n        ",
              "line_number": 900,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_check_for_arweave_patterns",
              "signature": "(self, state: Any) -> bool",
              "docstring": "\n        Check if the puzzle state contains Arweave puzzle patterns.\n\n        Args:\n            state: Current puzzle state\n\n        Returns:\n            True if Arweave puzzle patterns are detected, False otherwise\n        ",
              "line_number": 963,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_create_arweave_tools",
              "signature": "(self, state: Any) -> List[str]",
              "docstring": "\n        Create specialized tools for Arweave puzzles.\n\n        Args:\n            state: Current puzzle state\n\n        Returns:\n            List of created tool IDs\n        ",
              "line_number": 1005,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_create_default_tools",
              "signature": "(self) -> List[str]",
              "docstring": "Create a set of default tools for cryptographic puzzles.",
              "line_number": 1048,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "integrate_with_state",
              "signature": "(self, state: Any, analyze_puzzle: bool) -> Any",
              "docstring": "\n        Integrate code analysis with the puzzle state.\n\n        Args:\n            state: Current puzzle state\n            analyze_puzzle: Whether to analyze the puzzle and create tools\n\n        Returns:\n            Updated state\n        ",
              "line_number": 1065,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": []
        }
      ],
      "constants": [],
      "file_size": 37580,
      "line_count": 1107
    },
    {
      "name": "core.binwalk_wrapper",
      "path": "core/binwalk_wrapper.py",
      "docstring": "\nBinwalk Wrapper Module\n\nThis module provides a wrapper around the binwalk command-line tool\nto provide the functionality needed by the project without requiring\nthe Python binwalk module with its core components.\n\nIt simulates the API of the Python binwalk module but uses subprocess\nto call the command-line binwalk tool instead.\n",
      "imports": [
        "import os",
        "import subprocess",
        "import tempfile",
        "from typing import Dict",
        "from typing import List",
        "from typing import Any",
        "from typing import Optional",
        "from typing import Union"
      ],
      "functions": [
        {
          "name": "scan",
          "signature": "(target_file: str, signature: bool, extract: bool, quiet: bool, directory: Optional[str]) -> List[Module]",
          "docstring": "\n    Scan a file using binwalk command-line tool.\n    \n    Args:\n        target_file: Path to the file to scan\n        signature: Whether to perform signature scanning\n        extract: Whether to extract identified files\n        quiet: Whether to suppress output\n        directory: Directory to extract files to\n        \n    Returns:\n        List of module objects with results\n    ",
          "line_number": 42,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [
        {
          "name": "ModuleException",
          "docstring": "Exception raised for errors in the binwalk module.",
          "line_number": 17,
          "methods": [],
          "base_classes": [
            "Exception"
          ],
          "decorators": []
        },
        {
          "name": "Module",
          "docstring": "Base class for binwalk modules.",
          "line_number": 21,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self)",
              "docstring": null,
              "line_number": 23,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": []
        },
        {
          "name": "Signature",
          "docstring": "Signature scanning module.",
          "line_number": 26,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self)",
              "docstring": null,
              "line_number": 28,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [
            "Module"
          ],
          "decorators": []
        },
        {
          "name": "Extraction",
          "docstring": "Extraction module.",
          "line_number": 31,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self)",
              "docstring": null,
              "line_number": 33,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [
            "Module"
          ],
          "decorators": []
        },
        {
          "name": "Modules",
          "docstring": "Container for binwalk modules.",
          "line_number": 36,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self)",
              "docstring": null,
              "line_number": 38,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": []
        }
      ],
      "constants": [],
      "file_size": 3790,
      "line_count": 122
    },
    {
      "name": "core.steganography_tools",
      "path": "core/steganography_tools.py",
      "docstring": "\nSteganography Tools Module\n\nThis module provides specialized tools for analyzing and extracting hidden data\nfrom various file types using steganography techniques. It includes tools for\nimage, audio, text, and binary steganography based on real-world CTF challenges.\n",
      "imports": [
        "import re",
        "import math",
        "import json",
        "import base64",
        "import binascii",
        "import struct",
        "import io",
        "import os",
        "import subprocess",
        "import tempfile",
        "from typing import Dict",
        "from typing import List",
        "from typing import Any",
        "from typing import Optional",
        "from typing import Tuple",
        "from typing import Union",
        "from typing import BinaryIO",
        "import numpy",
        "from PIL import Image",
        "import binwalk",
        "from binwalk.core.module import Modules",
        "from core.binwalk_wrapper import Modules",
        "from core.binwalk_wrapper import scan",
        "from core.binwalk_wrapper import ModuleException",
        "import types",
        "from core.binwalk_wrapper import Modules",
        "from core.binwalk_wrapper import scan",
        "from core.binwalk_wrapper import ModuleException"
      ],
      "functions": [
        {
          "name": "extract_image_lsb",
          "signature": "(data: bytes, bit_plane: int, channels: List[str]) -> Dict[str, Any]",
          "docstring": "\n    Extract least significant bits from image data.\n\n    Args:\n        data: Binary image data\n        bit_plane: Which bit plane to extract (0 = LSB, 1 = second bit, etc.)\n        channels: Which color channels to extract from (r, g, b, a)\n\n    Returns:\n        Dictionary with extracted data and analysis\n    ",
          "line_number": 68,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "extract_appended_data",
          "signature": "(data: bytes) -> Dict[str, Any]",
          "docstring": "\n    Extract data appended after file EOF markers.\n\n    Args:\n        data: Binary file data\n\n    Returns:\n        Dictionary with extracted appended data\n    ",
          "line_number": 158,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_audio_spectrogram",
          "signature": "(data: bytes) -> Dict[str, Any]",
          "docstring": "\n    Analyze audio file for hidden data in spectrogram.\n\n    Args:\n        data: Binary audio data\n\n    Returns:\n        Dictionary with spectrogram analysis\n    ",
          "line_number": 251,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_zero_width_chars",
          "signature": "(text: str) -> Dict[str, Any]",
          "docstring": "\n    Analyze text for zero-width characters that might hide data.\n\n    Args:\n        text: Text to analyze\n\n    Returns:\n        Dictionary with analysis results\n    ",
          "line_number": 350,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "extract_first_letters",
          "signature": "(text: str) -> Dict[str, Any]",
          "docstring": "\n    Extract first letters from lines or paragraphs to find hidden messages.\n\n    Args:\n        text: Text to analyze\n\n    Returns:\n        Dictionary with extracted messages\n    ",
          "line_number": 430,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "find_embedded_files",
          "signature": "(data: bytes) -> Dict[str, Any]",
          "docstring": "\n    Find embedded files within binary data.\n\n    Args:\n        data: Binary data to analyze\n\n    Returns:\n        Dictionary with found file signatures\n    ",
          "line_number": 473,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "run_zsteg",
          "signature": "(data: bytes) -> Dict[str, Any]",
          "docstring": "\n    Run zsteg on image data to detect steganography.\n\n    Args:\n        data: Binary image data\n\n    Returns:\n        Dictionary with zsteg analysis results\n    ",
          "line_number": 534,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "run_binwalk",
          "signature": "(data: bytes) -> Dict[str, Any]",
          "docstring": "\n    Run binwalk on binary data to find embedded files and signatures.\n\n    Args:\n        data: Binary data to analyze\n\n    Returns:\n        Dictionary with binwalk analysis results\n    ",
          "line_number": 608,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_stego",
          "signature": "(data: bytes, file_type: str) -> Dict[str, Any]",
          "docstring": "\n    Comprehensive steganography analysis for various file types.\n\n    Args:\n        data: Binary data to analyze\n        file_type: Optional file type hint\n\n    Returns:\n        Dictionary with analysis results\n    ",
          "line_number": 798,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 31875,
      "line_count": 892
    },
    {
      "name": "core.logger",
      "path": "core/logger.py",
      "docstring": "\nSolution Logger Module\nProvides real-time logging of the solution process.\n",
      "imports": [
        "import time",
        "from typing import Optional",
        "from typing import Dict",
        "from typing import Any",
        "from typing import List",
        "from typing import Callable",
        "from rich.console import Console",
        "from rich.panel import Panel",
        "from rich.table import Table",
        "from rich import box"
      ],
      "functions": [],
      "classes": [
        {
          "name": "SolutionLogger",
          "docstring": "\n    Class to handle real-time logging of the solution process.\n    ",
          "line_number": 15,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self, verbose: bool)",
              "docstring": "\n        Initialize the solution logger.\n\n        Args:\n            verbose: Whether to output detailed logs\n        ",
              "line_number": 19,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "log_insight",
              "signature": "(self, text: str, analyzer: str, time_str: Optional[str]) -> None",
              "docstring": "\n        Log an insight in real-time.\n\n        Args:\n            text: Insight text\n            analyzer: Name of the analyzer that generated the insight\n            time_str: Optional time string (if not provided, current time will be used)\n        ",
              "line_number": 36,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "log_transformation",
              "signature": "(self, name: str, description: str, input_data: str, output_data: str, analyzer: str, time_str: Optional[str]) -> None",
              "docstring": "\n        Log a transformation in real-time.\n\n        Args:\n            name: Name of the transformation\n            description: Description of what the transformation does\n            input_data: Input data for the transformation\n            output_data: Output data from the transformation\n            analyzer: Name of the analyzer that performed the transformation\n            time_str: Optional time string (if not provided, current time will be used)\n        ",
              "line_number": 74,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "log_solution",
              "signature": "(self, solution: str) -> None",
              "docstring": "\n        Log the solution in real-time.\n\n        Args:\n            solution: Solution to the puzzle\n        ",
              "line_number": 128,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_insights",
              "signature": "(self) -> List[Dict[str, Any]]",
              "docstring": "\n        Get all logged insights.\n\n        Returns:\n            List of insights\n        ",
              "line_number": 145,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_transformations",
              "signature": "(self) -> List[Dict[str, Any]]",
              "docstring": "\n        Get all logged transformations.\n\n        Returns:\n            List of transformations\n        ",
              "line_number": 154,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_solution",
              "signature": "(self) -> Optional[str]",
              "docstring": "\n        Get the logged solution.\n\n        Returns:\n            Solution or None if not found\n        ",
              "line_number": 163,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "register_llm_feedback_callback",
              "signature": "(self, callback: Callable[[str, str, str], None]) -> None",
              "docstring": "\n        Register a callback function to be called when new findings are logged.\n\n        Args:\n            callback: Function that takes (finding_type, analyzer, content) as arguments\n        ",
              "line_number": 172,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "get_pending_llm_feedback",
              "signature": "(self) -> List[Dict[str, Any]]",
              "docstring": "\n        Get all pending findings that need to be sent to the LLM.\n\n        Returns:\n            List of pending findings\n        ",
              "line_number": 181,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "clear_pending_llm_feedback",
              "signature": "(self) -> None",
              "docstring": "\n        Clear the list of pending findings.\n        ",
              "line_number": 190,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": []
        }
      ],
      "constants": [],
      "file_size": 9344,
      "line_count": 197
    },
    {
      "name": "core.vision_agent",
      "path": "core/vision_agent.py",
      "docstring": "\nVision agent for Crypto Hunter.\nAllows the agent to analyze images using AI vision capabilities.\n",
      "imports": [
        "import os",
        "import io",
        "import logging",
        "from typing import Dict",
        "from typing import Any",
        "from typing import Optional",
        "from typing import List",
        "from PIL import Image",
        "import base64",
        "from anthropic import Anthropic",
        "from openai import OpenAI"
      ],
      "functions": [],
      "classes": [
        {
          "name": "VisionAgent",
          "docstring": "\n    Agent capable of analyzing images using AI vision capabilities.\n    ",
          "line_number": 17,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self, provider, api_key, model)",
              "docstring": "\n        Initialize the VisionAgent.\n\n        Args:\n            provider: LLM provider to use (anthropic, openai)\n            api_key: Optional API key (if not provided, will use environment variables)\n            model: Optional model name (specific to the provider)\n        ",
              "line_number": 21,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_initialize_client",
              "signature": "(self)",
              "docstring": "\n        Initialize the client based on the provider.\n\n        Returns:\n            Client object or None if initialization fails\n        ",
              "line_number": 47,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "analyze_image",
              "signature": "(self, image_data: bytes, max_image_size: int) -> Dict[str, Any]",
              "docstring": "\n        Analyze an image using AI vision capabilities.\n\n        Args:\n            image_data: Binary image data\n            max_image_size: Maximum width or height for the image (to reduce token usage)\n\n        Returns:\n            Dictionary with analysis results\n        ",
              "line_number": 69,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_analyze_with_anthropic",
              "signature": "(self, image: Image.Image, max_image_size: int) -> Dict[str, Any]",
              "docstring": "\n        Analyze an image using Anthropic's Claude.\n\n        Args:\n            image: PIL Image object\n            max_image_size: Maximum width or height for the image\n\n        Returns:\n            Dictionary with analysis results\n        ",
              "line_number": 110,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_resize_image_if_needed",
              "signature": "(self, image: Image.Image, max_size: int) -> Image.Image",
              "docstring": "\n        Resize an image if it's too large, maintaining aspect ratio.\n\n        Args:\n            image: PIL Image object\n            max_size: Maximum width or height\n\n        Returns:\n            Resized PIL Image object\n        ",
              "line_number": 173,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_analyze_with_openai",
              "signature": "(self, image: Image.Image, max_image_size: int) -> Dict[str, Any]",
              "docstring": "\n        Analyze an image using OpenAI's GPT-4 Vision.\n\n        Args:\n            image: PIL Image object\n            max_image_size: Maximum width or height for the image\n\n        Returns:\n            Dictionary with analysis results\n        ",
              "line_number": 204,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "integrate_with_state",
              "signature": "(self, state, image_data: bytes, max_image_size: int) -> Any",
              "docstring": "\n        Integrate vision analysis results with the puzzle state.\n\n        Args:\n            state: Current puzzle state\n            image_data: Binary image data\n            max_image_size: Maximum width or height for the image (to reduce token usage)\n\n        Returns:\n            Updated state\n        ",
              "line_number": 265,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": []
        }
      ],
      "constants": [],
      "file_size": 10917,
      "line_count": 307
    }
  ],
  "analyzers": [
    {
      "name": "test_analyzer",
      "path": "test_analyzer.py",
      "docstring": "\nTest script to verify the fix for the text_analyzer issue.\n",
      "imports": [
        "from core.state import State",
        "from analyzers import get_analyzer"
      ],
      "functions": [
        {
          "name": "main",
          "signature": "()",
          "docstring": null,
          "line_number": 9,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 1169,
      "line_count": 37
    },
    {
      "name": "analyzers.cipher_analyzer",
      "path": "analyzers/cipher_analyzer.py",
      "docstring": "\nCipher analyzer for Crypto Hunter.\nDetects and solves various classical ciphers.\n",
      "imports": [
        "import re",
        "import string",
        "import collections",
        "from itertools import cycle",
        "from core.state import State",
        "from analyzers.base import register_analyzer",
        "from analyzers.base import analyzer_compatibility",
        "from math import isqrt"
      ],
      "functions": [
        {
          "name": "analyze_ciphers",
          "signature": "(state: State, cipher_type: str, input_data: str) -> State",
          "docstring": "\n    Detect and solve various classical ciphers in the text.\n\n    Args:\n        state: Current puzzle state\n        cipher_type: Optional specific cipher type to analyze\n        input_data: Optional specific data to analyze instead of state.puzzle_text\n\n    Returns:\n        Updated state\n    ",
          "line_number": 28,
          "is_async": false,
          "decorators": [
            "register_analyzer('cipher_analyzer')",
            "analyzer_compatibility(requires_text=True)"
          ]
        },
        {
          "name": "analyze_caesar_cipher",
          "signature": "(state: State, text: str, is_related, filename) -> None",
          "docstring": "\n    Analyze text for potential Caesar cipher.\n\n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n        is_related: Whether this is a related file\n        filename: Name of the related file (if applicable)\n    ",
          "line_number": 122,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_vigenere_cipher",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential Vigenère cipher.\n\n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 229,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_substitution_cipher",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential substitution cipher.\n\n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 338,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_transposition_cipher",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential transposition ciphers.\n\n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 407,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_baconian_cipher",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential Baconian cipher.\n\n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 518,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_atbash_cipher",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential Atbash cipher.\n\n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 614,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_rail_fence_cipher",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential Rail Fence cipher.\n    This is handled by the transposition cipher analysis.\n\n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 650,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_xor_cipher",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential XOR cipher.\n\n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 662,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "caesar_decode",
          "signature": "(text: str, shift: int) -> str",
          "docstring": "\n    Decode Caesar cipher with the given shift.\n\n    Args:\n        text: Encoded text\n        shift: Shift value (0-25)\n\n    Returns:\n        Decoded text\n    ",
          "line_number": 791,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "vigenere_decode",
          "signature": "(text: str, key: str) -> str",
          "docstring": "\n    Decode Vigenère cipher with the given key.\n\n    Args:\n        text: Encoded text\n        key: Encryption key\n\n    Returns:\n        Decoded text\n    ",
          "line_number": 814,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "simple_substitution_decode",
          "signature": "(text: str, mapping: dict) -> str",
          "docstring": "\n    Decode simple substitution cipher with the given mapping.\n\n    Args:\n        text: Encoded text\n        mapping: Dictionary mapping cipher letters to plain letters\n\n    Returns:\n        Decoded text\n    ",
          "line_number": 842,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "rail_fence_decode",
          "signature": "(text: str, rails: int) -> str",
          "docstring": "\n    Decode Rail Fence cipher with the given number of rails.\n\n    Args:\n        text: Encoded text\n        rails: Number of rails\n\n    Returns:\n        Decoded text\n    ",
          "line_number": 866,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "atbash_decode",
          "signature": "(text: str) -> str",
          "docstring": "\n    Decode Atbash cipher.\n\n    Args:\n        text: Encoded text\n\n    Returns:\n        Decoded text\n    ",
          "line_number": 920,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "find_repeating_sequences",
          "signature": "(text: str, min_length, max_length) -> dict",
          "docstring": "\n    Find repeating sequences in the text.\n\n    Args:\n        text: Text to analyze\n        min_length: Minimum sequence length to consider\n        max_length: Maximum sequence length to consider\n\n    Returns:\n        Dictionary mapping sequences to their positions\n    ",
          "line_number": 942,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "score_english_text",
          "signature": "(text: str) -> float",
          "docstring": "\n    Score text based on how likely it is to be valid English.\n\n    Args:\n        text: Text to score\n\n    Returns:\n        Score from 0.0 to 1.0 (higher is more likely to be English)\n    ",
          "line_number": 976,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [
        "ENGLISH_FREQ = 'ETAOINSRHDLUCMFYWGPBVKXQJZ'.lower()",
        "COMMON_ENGLISH_WORDS = {'the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'i', 'it', 'for', 'not', 'on', 'with', 'he', 'as', 'you', 'do', 'at', 'this', 'but', 'his', 'by', 'from', 'they', 'we', 'say', 'her', 'she', 'or', 'an', 'will', 'my', 'one', 'all', 'would', 'there', 'their', 'what', 'so', 'up', 'out', 'if', 'about', 'who', 'get', 'which', 'go', 'me', 'when', 'make', 'can', 'like', 'time', 'no', 'just', 'him', 'know', 'take'}"
      ],
      "file_size": 35346,
      "line_count": 1030
    },
    {
      "name": "analyzers.image_analyzer",
      "path": "analyzers/image_analyzer.py",
      "docstring": "\nEnhanced Image Analyzer with Advanced Steganography Capabilities\nIntegrates sophisticated steganography extraction techniques into Crypto Hunter\n",
      "imports": [
        "import io",
        "import re",
        "import math",
        "import zlib",
        "import struct",
        "import binascii",
        "import itertools",
        "from typing import List",
        "from typing import Tuple",
        "from typing import Optional",
        "from typing import Dict",
        "from typing import Any",
        "from typing import Union",
        "from typing import Callable",
        "from core.state import State",
        "from analyzers.base import register_analyzer",
        "from analyzers.base import analyzer_compatibility",
        "from PIL import Image",
        "from PIL import ExifTags",
        "from PIL import PngImagePlugin",
        "import numpy",
        "import cv2",
        "import os",
        "import os",
        "from core.steganography_tools import run_binwalk"
      ],
      "functions": [
        {
          "name": "_detect_file_type",
          "signature": "(data: bytes) -> Optional[str]",
          "docstring": "Detect file type from binary data",
          "line_number": 629,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "find_strings",
          "signature": "(data: bytes, min_length: int) -> List[Tuple[str, int]]",
          "docstring": "Find ASCII strings in binary data",
          "line_number": 655,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_image",
          "signature": "(state: State, **kwargs) -> State",
          "docstring": "\n    Comprehensive image analysis with advanced steganography extraction\n    ",
          "line_number": 684,
          "is_async": false,
          "decorators": [
            "register_analyzer('advanced_steganography')",
            "register_analyzer('steganography_analyzer')",
            "register_analyzer('steganography_extractor')",
            "register_analyzer('image_analyzer')",
            "analyzer_compatibility(requires_binary=True)"
          ]
        },
        {
          "name": "analyze_with_pil",
          "signature": "(state: State) -> None",
          "docstring": "Analyze image using PIL: dimensions, mode, format, color stats, metadata",
          "line_number": 860,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_rgb_image",
          "signature": "(state: State, image) -> None",
          "docstring": "Analyze RGB image for suspicious patterns",
          "line_number": 884,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_grayscale_image",
          "signature": "(state: State, image) -> None",
          "docstring": "Analyze grayscale image for suspicious patterns",
          "line_number": 905,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_palette_image",
          "signature": "(state: State, image) -> None",
          "docstring": "Analyze palette-based image",
          "line_number": 922,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_image_metadata",
          "signature": "(state: State, image) -> None",
          "docstring": "Extract and analyze image metadata",
          "line_number": 940,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "extract_text_from_image",
          "signature": "(state: State) -> None",
          "docstring": "Extract ASCII/UTF-8 strings from raw image data",
          "line_number": 983,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "check_basic_lsb_steganography",
          "signature": "(state: State) -> None",
          "docstring": "Basic LSB steganography detection",
          "line_number": 1020,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "extract_lsb_channel",
          "signature": "(image, channel: int) -> Optional[str]",
          "docstring": "Extract LSB bits from a specific channel",
          "line_number": 1109,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "has_pattern_in_lsb",
          "signature": "(bit_string: str) -> bool",
          "docstring": "Check if LSB bit string has suspicious patterns",
          "line_number": 1127,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "lsb_bits_to_text",
          "signature": "(bit_string: str) -> Optional[str]",
          "docstring": "Convert LSB bit string to text",
          "line_number": 1155,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "check_embedded_files",
          "signature": "(state: State) -> None",
          "docstring": "Check for files embedded within the image",
          "line_number": 1177,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_image_with_opencv",
          "signature": "(state: State) -> State",
          "docstring": "Fallback analysis using OpenCV when vision API is not available",
          "line_number": 1235,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [
        {
          "name": "AdvancedSteganographyExtractor",
          "docstring": "Advanced steganography extraction capabilities for Crypto Hunter",
          "line_number": 34,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self, image_data: bytes, verbose: bool, state: Optional['State'])",
              "docstring": null,
              "line_number": 37,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "extract_multi_bitplane_advanced",
              "signature": "(self) -> Dict[str, bytes]",
              "docstring": "Extract data from multiple bit planes with advanced configurations",
              "line_number": 68,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "extract_prime_fibonacci_patterns",
              "signature": "(self) -> Dict[str, bytes]",
              "docstring": "Extract data using prime and Fibonacci pixel indexing",
              "line_number": 250,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "extract_xor_patterns",
              "signature": "(self) -> Dict[str, bytes]",
              "docstring": "Extract data with XOR pattern analysis",
              "line_number": 277,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "extract_frequency_domain",
              "signature": "(self) -> Dict[str, bytes]",
              "docstring": "Extract data from DCT/DFT frequency domain",
              "line_number": 311,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "extract_png_chunks_advanced",
              "signature": "(self) -> Dict[str, bytes]",
              "docstring": "Advanced PNG chunk analysis",
              "line_number": 380,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_extract_bits_advanced",
              "signature": "(self, bit_plane: int, channel: int, bit_order: str, scan_order: str, filter_func: Optional[Callable]) -> List[int]",
              "docstring": "Advanced bit extraction with multiple parameters",
              "line_number": 450,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_scan_coordinates",
              "signature": "(self, width: int, height: int, scan_order: str) -> List[Tuple[int, int]]",
              "docstring": "Generate pixel coordinates based on scan order",
              "line_number": 490,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_spiral_coordinates",
              "signature": "(self, width: int, height: int) -> List[Tuple[int, int]]",
              "docstring": "Generate coordinates in spiral pattern",
              "line_number": 503,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_zigzag_coordinates",
              "signature": "(self, width: int, height: int) -> List[Tuple[int, int]]",
              "docstring": "Generate coordinates in zigzag pattern",
              "line_number": 525,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_get_special_filter",
              "signature": "(self, filter_type: str) -> Callable",
              "docstring": "Get special pixel filter function",
              "line_number": 543,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_is_prime",
              "signature": "(self, n: int) -> bool",
              "docstring": "Check if number is prime",
              "line_number": 552,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_is_fibonacci",
              "signature": "(self, n: int) -> bool",
              "docstring": "Check if number is Fibonacci",
              "line_number": 567,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_bits_to_bytes",
              "signature": "(self, bits: List[int]) -> bytes",
              "docstring": "Convert list of bits to bytes",
              "line_number": 578,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_is_meaningful_data",
              "signature": "(self, data: bytes) -> bool",
              "docstring": "Check if extracted data appears meaningful",
              "line_number": 596,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": []
        }
      ],
      "constants": [],
      "file_size": 52007,
      "line_count": 1240
    },
    {
      "name": "analyzers.blockchain_analyzer",
      "path": "analyzers/blockchain_analyzer.py",
      "docstring": "\nBlockchain analyzer module for Crypto Hunter\n\nThis module provides functions for analyzing blockchain data,\nincluding Ethereum addresses, transactions, and encoded messages.\n",
      "imports": [
        "import logging",
        "import re",
        "import binascii",
        "import hashlib",
        "import json",
        "from typing import Dict",
        "from typing import List",
        "from typing import Any",
        "from typing import Optional",
        "from typing import Tuple",
        "from typing import Union",
        "import requests",
        "from core.state import State",
        "from analyzers.base import register_analyzer",
        "from analyzers.base import analyzer_compatibility",
        "import config",
        "from web3 import Web3",
        "from eth_utils import decode_hex",
        "from eth_utils import to_checksum_address",
        "from eth_utils import is_address"
      ],
      "functions": [
        {
          "name": "analyze_blockchain",
          "signature": "(state: State, hex_strings, metadata) -> State",
          "docstring": "\n    Main blockchain analyzer function that orchestrates blockchain analysis.\n\n    Args:\n        state: Current puzzle state\n        hex_strings: Optional hex strings to analyze\n        metadata: Optional metadata for analysis\n\n    Returns:\n        Updated state after analysis\n    ",
          "line_number": 36,
          "is_async": false,
          "decorators": [
            "register_analyzer('blockchain_analyzer')",
            "analyzer_compatibility()"
          ]
        },
        {
          "name": "detect_addresses",
          "signature": "(state: State) -> State",
          "docstring": "\n    Detect blockchain addresses in the puzzle data.\n\n    Args:\n        state: Current puzzle state\n\n    Returns:\n        Updated state after analysis\n    ",
          "line_number": 57,
          "is_async": false,
          "decorators": [
            "register_analyzer('detect_addresses')"
          ]
        },
        {
          "name": "analyze_ethereum_data",
          "signature": "(state: State) -> State",
          "docstring": "\n    Analyze Ethereum addresses and transactions.\n\n    Args:\n        state: Current puzzle state\n\n    Returns:\n        Updated state after analysis\n    ",
          "line_number": 187,
          "is_async": false,
          "decorators": [
            "register_analyzer('analyze_ethereum_data')"
          ]
        },
        {
          "name": "check_encoded_messages",
          "signature": "(state: State) -> State",
          "docstring": "\n    Check for encoded messages in blockchain data.\n\n    Args:\n        state: Current puzzle state\n\n    Returns:\n        Updated state after analysis\n    ",
          "line_number": 291,
          "is_async": false,
          "decorators": [
            "register_analyzer('check_encoded_messages')"
          ]
        },
        {
          "name": "is_ethereum_address",
          "signature": "(address: str) -> bool",
          "docstring": "\n    Check if a string is a valid Ethereum address.\n\n    Args:\n        address: Address string to check\n\n    Returns:\n        True if valid, False otherwise\n    ",
          "line_number": 356,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "is_bitcoin_address",
          "signature": "(address: str) -> bool",
          "docstring": "\n    Check if a string is a valid Bitcoin address.\n\n    Args:\n        address: Address string to check\n\n    Returns:\n        True if valid, False otherwise\n    ",
          "line_number": 398,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "get_ethereum_transactions",
          "signature": "(address: str) -> List[Dict[str, Any]]",
          "docstring": "\n    Get transaction data for an Ethereum address.\n\n    Args:\n        address: Ethereum address\n\n    Returns:\n        List of transaction data or empty list if failed\n    ",
          "line_number": 428,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "find_interesting_transactions",
          "signature": "(transactions: List[Dict[str, Any]]) -> List[Dict[str, Any]]",
          "docstring": "\n    Find interesting transactions for cryptographic puzzles.\n\n    Args:\n        transactions: List of transaction data\n\n    Returns:\n        List of interesting transactions with reasons\n    ",
          "line_number": 467,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "find_transactions_with_data",
          "signature": "(transactions: List[Dict[str, Any]]) -> List[Dict[str, Any]]",
          "docstring": "\n    Find transactions containing data.\n\n    Args:\n        transactions: List of transaction data\n\n    Returns:\n        List of transactions with data\n    ",
          "line_number": 509,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "decode_transaction_data",
          "signature": "(data: str) -> Optional[str]",
          "docstring": "\n    Attempt to decode transaction data.\n\n    Args:\n        data: Transaction data (hex string)\n\n    Returns:\n        Decoded data or None if not decodable\n    ",
          "line_number": 535,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "is_contract_address",
          "signature": "(address: str) -> bool",
          "docstring": "\n    Check if an Ethereum address is a contract.\n\n    Args:\n        address: Ethereum address\n\n    Returns:\n        True if contract, False otherwise\n    ",
          "line_number": 576,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "get_contract_code",
          "signature": "(address: str) -> Optional[str]",
          "docstring": "\n    Get the bytecode of a contract.\n\n    Args:\n        address: Ethereum address\n\n    Returns:\n        Contract code or None if not available\n    ",
          "line_number": 598,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "address_to_message",
          "signature": "(addresses: List[str]) -> Optional[str]",
          "docstring": "\n    Check if a list of addresses might encode a message.\n\n    Args:\n        addresses: List of Ethereum addresses\n\n    Returns:\n        Decoded message or None if no message found\n    ",
          "line_number": 638,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "get_bitcoin_op_return",
          "signature": "(address: str) -> List[str]",
          "docstring": "\n    Get OP_RETURN data from transactions involving a Bitcoin address.\n\n    Args:\n        address: Bitcoin address\n\n    Returns:\n        List of OP_RETURN data\n    ",
          "line_number": 684,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "detect_crypto_addresses",
          "signature": "(text: str) -> List[str]",
          "docstring": "\n    Detect cryptocurrency addresses in text.\n\n    This function detects various cryptocurrency address formats:\n    1. Standard Ethereum addresses (0x...)\n    2. Extended format Ethereum addresses (0xFF...) as seen in some puzzles\n    3. Legacy Bitcoin addresses (1... or 3...)\n    4. Bech32 Bitcoin addresses (bc1...)\n\n    Args:\n        text: Text to search for addresses\n\n    Returns:\n        List of detected cryptocurrency addresses\n    ",
          "line_number": 737,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [
        "INFURA_ENDPOINT = f'https://mainnet.infura.io/v3/{config.ETHERSCAN_API_KEY}' if config.ETHERSCAN_API_KEY else None"
      ],
      "file_size": 25698,
      "line_count": 795
    },
    {
      "name": "analyzers.code_analyzer",
      "path": "analyzers/code_analyzer.py",
      "docstring": "\nCode analyzer for Crypto Hunter.\nIntegrates the CodingAgent into the analysis flow.\n",
      "imports": [
        "import logging",
        "from typing import Dict",
        "from typing import Any",
        "from typing import Optional",
        "from typing import List",
        "from core.state import State",
        "from core.coding_agent import CodingAgent",
        "from analyzers.base import register_analyzer",
        "from analyzers.base import analyzer_compatibility"
      ],
      "functions": [
        {
          "name": "analyze_code",
          "signature": "(state: State, task_description: str, **kwargs) -> State",
          "docstring": "\n    Analyze the puzzle using Python code generation and execution.\n    \n    Args:\n        state: Current puzzle state\n        task_description: Optional task description for code generation\n        \n    Returns:\n        Updated state\n    ",
          "line_number": 18,
          "is_async": false,
          "decorators": [
            "register_analyzer('code_analyzer')",
            "analyzer_compatibility(file_types=['*'], binary=True, text=True)"
          ]
        },
        {
          "name": "_generate_task_description",
          "signature": "(state: State) -> str",
          "docstring": "\n    Generate a task description based on the puzzle state.\n    \n    Args:\n        state: Current puzzle state\n        \n    Returns:\n        Task description\n    ",
          "line_number": 82,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "_verify_solution",
          "signature": "(solution: str) -> bool",
          "docstring": "\n    Perform basic verification of a potential solution.\n    \n    Args:\n        solution: Potential solution\n        \n    Returns:\n        True if the solution seems valid, False otherwise\n    ",
          "line_number": 131,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 5186,
      "line_count": 151
    },
    {
      "name": "analyzers.cryptographic_analyzer",
      "path": "analyzers/cryptographic_analyzer.py",
      "docstring": "\nCryptographic analyzer module.\nThis is an alias for the crypto_analyzer module.\n",
      "imports": [
        "from core.state import State",
        "from analyzers.crypto_analyzer import analyze_crypto",
        "from analyzers.base import register_analyzer",
        "from analyzers.base import analyzer_compatibility"
      ],
      "functions": [
        {
          "name": "analyze_cryptographic",
          "signature": "(state: State) -> State",
          "docstring": "\n    Analyze the puzzle for cryptographic elements.\n    This is an alias for the analyze_crypto function.\n\n    Args:\n        state: Current puzzle state\n\n    Returns:\n        Updated state with crypto analysis insights\n    ",
          "line_number": 12,
          "is_async": false,
          "decorators": [
            "register_analyzer('cryptographic_analyzer')",
            "analyzer_compatibility(requires_text=True)"
          ]
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 646,
      "line_count": 23
    },
    {
      "name": "analyzers.web_analyzer",
      "path": "analyzers/web_analyzer.py",
      "docstring": "\nWeb analyzer for Crypto Hunter.\nIntegrates the WebAgent into the analysis flow.\n",
      "imports": [
        "import re",
        "import logging",
        "from typing import Dict",
        "from typing import Any",
        "from typing import Optional",
        "from typing import List",
        "from core.state import State",
        "from core.web_agent import WebAgent",
        "from analyzers.base import register_analyzer",
        "from analyzers.base import analyzer_compatibility"
      ],
      "functions": [
        {
          "name": "analyze_web",
          "signature": "(state: State, query: str, **kwargs) -> State",
          "docstring": "\n    Analyze web content related to the puzzle.\n    \n    Args:\n        state: Current puzzle state\n        query: Optional search query (if not provided, will be generated from the puzzle content)\n        \n    Returns:\n        Updated state\n    ",
          "line_number": 19,
          "is_async": false,
          "decorators": [
            "register_analyzer('web_analyzer')",
            "analyzer_compatibility(file_types=['*'], binary=True, text=True)"
          ]
        },
        {
          "name": "_generate_search_query",
          "signature": "(state: State) -> str",
          "docstring": "\n    Generate a search query based on the puzzle content.\n    \n    Args:\n        state: Current puzzle state\n        \n    Returns:\n        Search query\n    ",
          "line_number": 46,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 2322,
      "line_count": 82
    },
    {
      "name": "analyzers.text_analyzer",
      "path": "analyzers/text_analyzer.py",
      "docstring": "\nText analyzer for Crypto Hunter.\nAnalyzes text patterns to identify potential encodings and ciphers.\n",
      "imports": [
        "import re",
        "import string",
        "import collections",
        "from core.state import State",
        "from analyzers.base import register_analyzer",
        "from analyzers.base import analyzer_compatibility",
        "import math"
      ],
      "functions": [
        {
          "name": "analyze_text",
          "signature": "(state: State) -> State",
          "docstring": "\n    Analyze text patterns to identify potential encodings and ciphers.\n    \n    Args:\n        state: Current puzzle state\n        \n    Returns:\n        Updated state\n    ",
          "line_number": 14,
          "is_async": false,
          "decorators": [
            "register_analyzer('text_analyzer')",
            "analyzer_compatibility(requires_text=True)"
          ]
        },
        {
          "name": "analyze_character_distribution",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze character distribution in the text.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 67,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_word_patterns",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze word patterns in the text.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 157,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_potential_encodings",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze if the text matches patterns of common encodings.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 243,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_line_patterns",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze patterns across different lines in the text.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 317,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 12606,
      "line_count": 363
    },
    {
      "name": "analyzers.encoding_analyzer",
      "path": "analyzers/encoding_analyzer.py",
      "docstring": "\nEncoding analyzer for Crypto Hunter.\nDetects and decodes various encodings including Base64, Hex, ASCII85, Binary, URL, Morse, etc.\n",
      "imports": [
        "import re",
        "import os",
        "import base64",
        "import binascii",
        "import string",
        "import urllib.parse",
        "from core.state import State",
        "from analyzers.base import register_analyzer",
        "from analyzers.base import analyzer_compatibility",
        "import html",
        "import quopri",
        "import uu",
        "import tempfile"
      ],
      "functions": [
        {
          "name": "analyze_encodings",
          "signature": "(state: State) -> State",
          "docstring": "\n    Detect and decode various encodings in the text.\n    \n    Args:\n        state: Current puzzle state\n        \n    Returns:\n        Updated state\n    ",
          "line_number": 39,
          "is_async": false,
          "decorators": [
            "register_analyzer('encoding_analyzer')",
            "analyzer_compatibility(requires_text=True)"
          ]
        },
        {
          "name": "analyze_base64",
          "signature": "(state: State, text: str, is_related, filename) -> None",
          "docstring": "\n    Analyze text for potential Base64 encoding.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n        is_related: Whether this is a related file\n        filename: Name of the related file (if applicable)\n    ",
          "line_number": 96,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_base32",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential Base32 encoding.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 203,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_base85_ascii85",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential Base85/ASCII85 encoding.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 294,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_hex",
          "signature": "(state: State, text: str, is_related, filename) -> None",
          "docstring": "\n    Analyze text for potential hexadecimal encoding.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n        is_related: Whether this is a related file\n        filename: Name of the related file (if applicable)\n    ",
          "line_number": 423,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_binary",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential binary encoding.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 514,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_decimal",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential decimal encoding (ASCII codes).\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 595,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_url_encoding",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential URL encoding.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 679,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_html_entities",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential HTML entities.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 720,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_morse_code",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential Morse code.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 762,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_rot13",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential ROT13 encoding.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 821,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_quoted_printable",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential Quoted-Printable encoding.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 862,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_uuencoding",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential UUencoding.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 904,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_leetspeak",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text for potential leetspeak encoding.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 993,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "rot13_char",
          "signature": "(c: str) -> str",
          "docstring": "\n    Apply ROT13 to a single character.\n    \n    Args:\n        c: Character to transform\n        \n    Returns:\n        Transformed character\n    ",
          "line_number": 1052,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [
        "CONFIDENCE_THRESHOLD = 0.7",
        "MORSE_CODE_DICT = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', '0': '-----', '.': '.-.-.-', ',': '--..--', '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.', ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-', '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-', '@': '.--.-.', ' ': '/'}",
        "MORSE_CODE_REVERSE = {value: key for (key, value) in MORSE_CODE_DICT.items()}"
      ],
      "file_size": 38360,
      "line_count": 1073
    },
    {
      "name": "analyzers.crypto_analyzer",
      "path": "analyzers/crypto_analyzer.py",
      "docstring": "\nCrypto Analyzer for CryptoPuzzle-hunter.\nProvides advanced cryptographic analysis capabilities beyond classical ciphers.\nSpecializes in blockchain, wallet analysis, and cryptocurrency forensics.\n",
      "imports": [
        "import os",
        "import hashlib",
        "import base64",
        "import binascii",
        "import re",
        "import json",
        "import requests",
        "from typing import Dict",
        "from typing import List",
        "from typing import Tuple",
        "from typing import Optional",
        "from typing import Any",
        "from typing import Union",
        "from core.state import State",
        "from core.steganography_tools import analyze_stego",
        "from core.steganography_tools import run_zsteg",
        "from core.steganography_tools import run_binwalk",
        "from analyzers.base import register_analyzer",
        "from analyzers.base import analyzer_compatibility"
      ],
      "functions": [
        {
          "name": "analyze_crypto",
          "signature": "(state: State) -> State",
          "docstring": "\n    Analyze the puzzle for modern cryptographic elements.\n\n    This analyzer focuses on:\n    1. Hash identification and cracking attempts\n    2. Base64 and other encodings\n    3. Modern encryption algorithms\n    4. Blockchain-related cryptography\n    5. Digital signatures\n    6. Wallet file detection and analysis\n    7. Private key identification\n    8. Blockchain transaction analysis\n    9. Smart contract analysis\n\n    Args:\n        state: Current puzzle state\n\n    Returns:\n        Updated state with crypto analysis insights\n    ",
          "line_number": 22,
          "is_async": false,
          "decorators": [
            "register_analyzer('crypto_analyzer')",
            "analyzer_compatibility(requires_text=True)"
          ]
        },
        {
          "name": "identify_hashes",
          "signature": "(text: str) -> List[Tuple[str, str]]",
          "docstring": "\n    Identify potential cryptographic hashes in the text.\n\n    Args:\n        text: Text to analyze\n\n    Returns:\n        List of (hash_type, hash_value) tuples\n    ",
          "line_number": 302,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "is_likely_hash",
          "signature": "(hex_string: str) -> bool",
          "docstring": "\n    Check if a hex string is likely to be a hash by analyzing its entropy.\n\n    Args:\n        hex_string: Hexadecimal string to check\n\n    Returns:\n        True if the string is likely a hash, False otherwise\n    ",
          "line_number": 332,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "attempt_hash_crack",
          "signature": "(hash_value: str, hash_type: str) -> Optional[str]",
          "docstring": "\n    Attempt to crack a hash using a small dictionary of common values.\n\n    Args:\n        hash_value: The hash to crack\n        hash_type: Type of hash (MD5, SHA1, SHA256)\n\n    Returns:\n        Cracked plaintext if successful, None otherwise\n    ",
          "line_number": 357,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "identify_and_decode_base64",
          "signature": "(text: str) -> List[Tuple[str, str]]",
          "docstring": "\n    Identify and decode potential Base64 encoded strings.\n\n    Args:\n        text: Text to analyze\n\n    Returns:\n        List of (original, decoded) tuples\n    ",
          "line_number": 395,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "identify_and_decode_hex",
          "signature": "(text: str) -> List[Tuple[str, str]]",
          "docstring": "\n    Identify and decode potential hexadecimal encoded strings.\n\n    Args:\n        text: Text to analyze\n\n    Returns:\n        List of (original, decoded) tuples\n    ",
          "line_number": 430,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "identify_blockchain_addresses",
          "signature": "(text: str) -> List[Tuple[str, str]]",
          "docstring": "\n    Identify potential blockchain addresses in the text.\n\n    Args:\n        text: Text to analyze\n\n    Returns:\n        List of (address_type, address) tuples\n    ",
          "line_number": 464,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "identify_pgp_elements",
          "signature": "(text: str) -> List[Tuple[str, str]]",
          "docstring": "\n    Identify PGP/GPG elements like signatures, keys, or encrypted messages.\n\n    Args:\n        text: Text to analyze\n\n    Returns:\n        List of (element_type, content) tuples\n    ",
          "line_number": 490,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "identify_private_keys",
          "signature": "(text: str) -> List[Tuple[str, str]]",
          "docstring": "\n    Identify potential cryptocurrency private keys in the text.\n\n    Args:\n        text: Text to analyze\n\n    Returns:\n        List of (key_type, key_value) tuples\n    ",
          "line_number": 528,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "is_likely_mnemonic",
          "signature": "(phrase: str) -> bool",
          "docstring": "\n    Check if a phrase is likely to be a BIP39 mnemonic seed phrase.\n\n    Args:\n        phrase: The phrase to check\n\n    Returns:\n        True if the phrase is likely a mnemonic, False otherwise\n    ",
          "line_number": 580,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "identify_wallet_files",
          "signature": "(text: str) -> List[Tuple[str, str]]",
          "docstring": "\n    Identify cryptocurrency wallet files in JSON format.\n\n    Args:\n        text: Text to analyze\n\n    Returns:\n        List of (wallet_type, wallet_content) tuples\n    ",
          "line_number": 619,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "extract_wallet_address",
          "signature": "(wallet_type: str, wallet_content: str) -> Optional[str]",
          "docstring": "\n    Extract wallet address from wallet file content.\n\n    Args:\n        wallet_type: Type of wallet\n        wallet_content: Wallet file content\n\n    Returns:\n        Wallet address if found, None otherwise\n    ",
          "line_number": 674,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_binary_for_wallets",
          "signature": "(binary_data: bytes) -> List[Tuple[str, str]]",
          "docstring": "\n    Analyze binary data for wallet files.\n\n    Args:\n        binary_data: Binary data to analyze\n\n    Returns:\n        List of (wallet_type, wallet_info) tuples\n    ",
          "line_number": 769,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_ethereum_address",
          "signature": "(address: str) -> Optional[str]",
          "docstring": "\n    Analyze an Ethereum address using Etherscan API.\n\n    Args:\n        address: Ethereum address to analyze\n\n    Returns:\n        Analysis results as a string, or None if analysis failed\n    ",
          "line_number": 809,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "identify_smart_contracts",
          "signature": "(text: str) -> List[Tuple[str, str]]",
          "docstring": "\n    Identify smart contract code in the text.\n\n    Args:\n        text: Text to analyze\n\n    Returns:\n        List of (contract_type, code) tuples\n    ",
          "line_number": 884,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_smart_contract",
          "signature": "(contract_type: str, code: str) -> Optional[str]",
          "docstring": "\n    Perform basic analysis of smart contract code.\n\n    Args:\n        contract_type: Type of contract (Solidity, Vyper)\n        code: Contract code\n\n    Returns:\n        Analysis results as a string, or None if analysis failed\n    ",
          "line_number": 928,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 42264,
      "line_count": 992
    },
    {
      "name": "analyzers.base",
      "path": "analyzers/base.py",
      "docstring": "\nBase module for analyzers.\nProvides registration mechanisms and utility functions.\n",
      "imports": [
        "import functools",
        "import inspect",
        "from typing import Dict",
        "from typing import Callable",
        "from typing import Any",
        "from typing import List"
      ],
      "functions": [
        {
          "name": "register_analyzer",
          "signature": "(name)",
          "docstring": "\n    Decorator to register an analyzer function.\n\n    Args:\n        name: Name of the analyzer\n\n    Returns:\n        Decorator function\n    ",
          "line_number": 13,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyzer_compatibility",
          "signature": "(**kwargs)",
          "docstring": "\n    Decorator to specify analyzer compatibility requirements.\n\n    Args:\n        **kwargs: Compatibility requirements (e.g., requires_text=True)\n\n    Returns:\n        Decorator function\n    ",
          "line_number": 28,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "get_analyzer",
          "signature": "(name: str) -> Callable",
          "docstring": "\n    Get an analyzer by name.\n\n    Args:\n        name: Name of the analyzer\n\n    Returns:\n        Analyzer function\n    ",
          "line_number": 87,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "get_all_analyzers",
          "signature": "() -> Dict[str, Callable]",
          "docstring": "\n    Get all registered analyzers.\n\n    Returns:\n        Dictionary of analyzer names to functions\n    ",
          "line_number": 99,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "get_compatible_analyzers",
          "signature": "(state) -> List[str]",
          "docstring": "\n    Get names of analyzers compatible with the current state.\n\n    Args:\n        state: Current puzzle state\n\n    Returns:\n        List of compatible analyzer names\n    ",
          "line_number": 108,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [
        "_ANALYZERS = {}"
      ],
      "file_size": 3944,
      "line_count": 135
    },
    {
      "name": "analyzers.text_pattern_analyzer",
      "path": "analyzers/text_pattern_analyzer.py",
      "docstring": "\nText pattern analyzer for Crypto Hunter.\nFocuses on advanced pattern recognition in text for cryptographic puzzles.\n",
      "imports": [
        "import re",
        "import string",
        "import collections",
        "from core.state import State",
        "from analyzers.base import register_analyzer",
        "from analyzers.base import analyzer_compatibility"
      ],
      "functions": [
        {
          "name": "analyze_text_patterns",
          "signature": "(state: State) -> State",
          "docstring": "\n    Analyze advanced text patterns to identify potential cryptographic features.\n    \n    Args:\n        state: Current puzzle state\n        \n    Returns:\n        Updated state\n    ",
          "line_number": 14,
          "is_async": false,
          "decorators": [
            "register_analyzer('text_pattern_analyzer')",
            "analyzer_compatibility(requires_text=True)"
          ]
        },
        {
          "name": "analyze_repeating_patterns",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze repeating patterns in the text.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 43,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_positional_patterns",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze patterns based on character positions.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 77,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_regex_patterns",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze text using regular expression patterns.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 112,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_cryptographic_patterns",
          "signature": "(state: State, text: str) -> None",
          "docstring": "\n    Analyze patterns that might indicate specific cryptographic techniques.\n    \n    Args:\n        state: Current puzzle state\n        text: Text to analyze\n    ",
          "line_number": 148,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 8124,
      "line_count": 203
    },
    {
      "name": "analyzers.vision_analyzer",
      "path": "analyzers/vision_analyzer.py",
      "docstring": "\nVision analyzer for Crypto Hunter.\nIntegrates the VisionAgent into the analysis flow.\n",
      "imports": [
        "import logging",
        "from typing import Dict",
        "from typing import Any",
        "from typing import Optional",
        "from typing import List",
        "from core.state import State",
        "from core.vision_agent import VisionAgent",
        "from analyzers.base import register_analyzer",
        "from analyzers.base import analyzer_compatibility",
        "from analyzers.image_analyzer import analyze_image_with_opencv"
      ],
      "functions": [
        {
          "name": "analyze_vision",
          "signature": "(state: State, provider, api_key, model, max_image_size, **kwargs) -> State",
          "docstring": "\n    Analyze images using AI vision capabilities.\n\n    Args:\n        state: Current puzzle state\n        provider: LLM provider to use (anthropic, openai)\n        api_key: Optional API key (if not provided, will use environment variables)\n        model: Optional model name (specific to the provider)\n        max_image_size: Maximum width or height for the image (to reduce token usage)\n\n    Returns:\n        Updated state\n    ",
          "line_number": 19,
          "is_async": false,
          "decorators": [
            "register_analyzer('vision_analyzer')",
            "analyzer_compatibility(file_types=['png', 'jpg', 'jpeg', 'gif', 'bmp', 'tiff', 'webp'], binary=True, text=False)"
          ]
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 2080,
      "line_count": 59
    },
    {
      "name": "analyzers.binwalk_analyzer",
      "path": "analyzers/binwalk_analyzer.py",
      "docstring": "\nBinwalk analyzer module.\nProvides functionality to analyze binary data using binwalk.\n",
      "imports": [
        "from core.state import State",
        "from core.steganography_tools import run_binwalk",
        "from analyzers.base import register_analyzer",
        "from analyzers.base import analyzer_compatibility"
      ],
      "functions": [
        {
          "name": "analyze_binwalk",
          "signature": "(state: State) -> State",
          "docstring": "\n    Analyze binary data using binwalk to find embedded files and signatures.\n\n    Args:\n        state: Current puzzle state\n\n    Returns:\n        Updated state with binwalk analysis insights\n    ",
          "line_number": 12,
          "is_async": false,
          "decorators": [
            "register_analyzer('binwalk')",
            "analyzer_compatibility(requires_binary=True)"
          ]
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 2309,
      "line_count": 67
    },
    {
      "name": "analyzers.binary_analyzer",
      "path": "analyzers/binary_analyzer.py",
      "docstring": "\nBinary analyzer for Crypto Hunter.\nAnalyzes binary data to identify file types, hidden data, and potential steganography.\n",
      "imports": [
        "import os",
        "import re",
        "import string",
        "import binascii",
        "import struct",
        "from collections import Counter",
        "from core.state import State",
        "from analyzers.base import register_analyzer",
        "from analyzers.base import analyzer_compatibility",
        "from core.steganography_tools import run_binwalk",
        "import math"
      ],
      "functions": [
        {
          "name": "analyze_binary",
          "signature": "(state: State) -> State",
          "docstring": "\n    Analyze binary data for file signatures, hidden data, and other patterns.\n\n    Args:\n        state: Current puzzle state\n\n    Returns:\n        Updated state\n    ",
          "line_number": 60,
          "is_async": false,
          "decorators": [
            "register_analyzer('binary_analyzer')",
            "analyzer_compatibility(requires_binary=True)"
          ]
        },
        {
          "name": "identify_file_type",
          "signature": "(state: State, data: bytes) -> None",
          "docstring": "\n    Identify the file type based on signatures.\n\n    Args:\n        state: Current puzzle state\n        data: Binary data to analyze\n    ",
          "line_number": 120,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "identify_file_type_from_data",
          "signature": "(data: bytes) -> str",
          "docstring": "\n    Identify file type from binary data.\n\n    Args:\n        data: Binary data to analyze\n\n    Returns:\n        String describing the identified file type, or None if not identified\n    ",
          "line_number": 165,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "check_for_embedded_files",
          "signature": "(state: State, data: bytes) -> None",
          "docstring": "\n    Check for embedded files within the binary data.\n\n    Args:\n        state: Current puzzle state\n        data: Binary data to analyze\n    ",
          "line_number": 180,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "analyze_entropy",
          "signature": "(state: State, data: bytes) -> None",
          "docstring": "\n    Analyze the entropy of the binary data.\n\n    Args:\n        state: Current puzzle state\n        data: Binary data to analyze\n    ",
          "line_number": 268,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "check_for_hidden_text",
          "signature": "(state: State, data: bytes) -> None",
          "docstring": "\n    Check for hidden text within the binary data.\n\n    Args:\n        state: Current puzzle state\n        data: Binary data to analyze\n    ",
          "line_number": 364,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "check_for_unusual_patterns",
          "signature": "(state: State, data: bytes) -> None",
          "docstring": "\n    Check for unusual patterns in the binary data.\n\n    Args:\n        state: Current puzzle state\n        data: Binary data to analyze\n    ",
          "line_number": 435,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "find_strings",
          "signature": "(data: bytes, min_length) -> list",
          "docstring": "\n    Find ASCII strings in binary data.\n\n    Args:\n        data: Binary data to search\n        min_length: Minimum string length to consider\n\n    Returns:\n        List of tuples (string, offset)\n    ",
          "line_number": 506,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "find_repeating_patterns",
          "signature": "(data: bytes, min_length, max_length) -> bytes",
          "docstring": "\n    Find repeating byte patterns in the data.\n\n    Args:\n        data: Binary data to analyze\n        min_length: Minimum pattern length to consider\n        max_length: Maximum pattern length to consider\n\n    Returns:\n        The repeating pattern, or None if none found\n    ",
          "line_number": 538,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "detect_xor",
          "signature": "(data: bytes) -> int",
          "docstring": "\n    Detect if data might be XOR encoded.\n\n    Args:\n        data: Binary data to analyze\n\n    Returns:\n        Potential XOR key, or None if not detected\n    ",
          "line_number": 570,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "detect_bit_shift",
          "signature": "(data: bytes) -> int",
          "docstring": "\n    Detect if data might be bit-shifted.\n\n    Args:\n        data: Binary data to analyze\n\n    Returns:\n        Number of bits shifted (positive for right, negative for left),\n        or None if not detected\n    ",
          "line_number": 606,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [
        "FILE_SIGNATURES = {b'\\x89PNG\\r\\n\\x1a\\n': 'PNG image', b'\\xff\\xd8\\xff': 'JPEG image', b'GIF87a': 'GIF image (87a)', b'GIF89a': 'GIF image (89a)', b'BM': 'BMP image', b'%PDF': 'PDF document', b'PK\\x03\\x04': 'ZIP archive', b'Rar!\\x1a\\x07': 'RAR archive', b'\\x1f\\x8b\\x08': 'GZIP archive', b'ID3': 'MP3 audio (with ID3)', b'\\xff\\xfb': 'MP3 audio', b'OggS': 'OGG audio/video', b'\\x00\\x00\\x00 ftyp': 'MP4 video/audio', b'MZ': 'Executable file', b'\\x7fELF': 'ELF executable', b'\\xca\\xfe\\xba\\xbe': 'Java class file', b'MZ\\x90\\x00': 'Windows executable', b'PK': 'ZIP-based file format', b'\\x1f\\x8b': 'GZIP compressed file', b'%!PS': 'PostScript document', b'{\\\\rtf': 'RTF document', b'PK\\x05\\x06': 'PKZIP archive', b'ustar': 'TAR archive', b'\\x00\\x01\\x00\\x00\\x00': 'TrueType font', b'RIFF': 'RIFF container (AVI, WAV)', b'OTTO': 'OpenType font', b'(\\xb5/\\xfd': 'Zstandard compressed data', b'FLV\\x01': 'Flash video', b'\\x00\\x00\\x01\\xba': 'MPEG transport stream', b'BZh': 'BZip2 compressed file', b'DICM': 'DICOM medical image', b'\\x1aE\\xdf\\xa3': 'Matroska multimedia container', b'x\\x01': 'ZLIB compressed data (low compression)', b'x\\x9c': 'ZLIB compressed data (default compression)', b'x\\xda': 'ZLIB compressed data (best compression)', b'NES\\x1a': 'Nintendo Entertainment System ROM', b'BOOKMOBI': 'MOBI ebook', b'QFI': 'QEMU copy-on-write disk image'}"
      ],
      "file_size": 22559,
      "line_count": 657
    }
  ],
  "tools": [
    {
      "name": "test_arweave_tools",
      "path": "test_arweave_tools.py",
      "docstring": "\nTest script to verify that Arweave tools are registered correctly when an Arweave puzzle is processed.\n",
      "imports": [
        "import os",
        "import sys",
        "from pathlib import Path",
        "from core.state import State",
        "from core.code_agent import CodeAgent",
        "from core.agent import CryptoAgent"
      ],
      "functions": [
        {
          "name": "test_arweave_tools_registration",
          "signature": "()",
          "docstring": "Test that Arweave tools are registered correctly.",
          "line_number": 14,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 2550,
      "line_count": 71
    },
    {
      "name": "tools.benchmark",
      "path": "tools/benchmark.py",
      "docstring": "\nBenchmarking Tool for Crypto Hunter Analyzers\n\nThis tool measures the performance of analyzers on different puzzles.\n",
      "imports": [
        "import os",
        "import sys",
        "import time",
        "import json",
        "import argparse",
        "from pathlib import Path",
        "from typing import Dict",
        "from typing import List",
        "from typing import Any",
        "from typing import Optional",
        "from datetime import datetime",
        "import matplotlib.pyplot",
        "from rich.console import Console",
        "from rich.table import Table",
        "from rich.progress import Progress",
        "from rich.progress import TextColumn",
        "from rich.progress import BarColumn",
        "from rich.progress import TimeElapsedColumn",
        "from core.state import State",
        "from analyzers.base import get_all_analyzers",
        "from analyzers.base import run_analyzer",
        "from analyzers.base import get_analyzer"
      ],
      "functions": [
        {
          "name": "parse_arguments",
          "signature": "()",
          "docstring": "Parse command line arguments.",
          "line_number": 28,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "get_puzzle_files",
          "signature": "(directory: str) -> List[str]",
          "docstring": "\n    Get list of puzzle files from a directory.\n    \n    Args:\n        directory: Directory path\n        \n    Returns:\n        List of file paths\n    ",
          "line_number": 61,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "run_benchmark",
          "signature": "(analyzers: Dict[str, Any], puzzle_files: List[str], iterations: int) -> Dict[str, Any]",
          "docstring": "\n    Run benchmark tests on analyzers and puzzles.\n    \n    Args:\n        analyzers: Dictionary of analyzers to test\n        puzzle_files: List of puzzle files to test\n        iterations: Number of iterations for each test\n        \n    Returns:\n        Benchmark results\n    ",
          "line_number": 77,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "display_results",
          "signature": "(results: Dict[str, Any])",
          "docstring": "\n    Display benchmark results in a table.\n    \n    Args:\n        results: Benchmark results\n    ",
          "line_number": 177,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "save_results",
          "signature": "(results: Dict[str, Any], file_path: str)",
          "docstring": "\n    Save benchmark results to a JSON file.\n    \n    Args:\n        results: Benchmark results\n        file_path: Path to save results\n    ",
          "line_number": 218,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "plot_results",
          "signature": "(results: Dict[str, Any], output_path: Optional[str])",
          "docstring": "\n    Plot benchmark results.\n    \n    Args:\n        results: Benchmark results\n        output_path: Path to save plot\n    ",
          "line_number": 235,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "main",
          "signature": "()",
          "docstring": "Main entry point.",
          "line_number": 289,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 10528,
      "line_count": 331
    },
    {
      "name": "tools.visualize_results",
      "path": "tools/visualize_results.py",
      "docstring": "\nResult Visualization Tool for Crypto Hunter\n\nThis tool visualizes analysis results from Crypto Hunter.\n",
      "imports": [
        "import os",
        "import sys",
        "import json",
        "import argparse",
        "from pathlib import Path",
        "from typing import Dict",
        "from typing import List",
        "from typing import Any",
        "from typing import Optional",
        "from datetime import datetime",
        "import matplotlib.pyplot",
        "import networkx",
        "from rich.console import Console",
        "from rich.table import Table",
        "from rich import box",
        "from rich.syntax import Syntax",
        "from core.state import State"
      ],
      "functions": [
        {
          "name": "parse_arguments",
          "signature": "()",
          "docstring": "Parse command line arguments.",
          "line_number": 28,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "load_result",
          "signature": "(file_path: str) -> Dict[str, Any]",
          "docstring": "\n    Load analysis result from JSON file.\n    \n    Args:\n        file_path: Path to result file\n        \n    Returns:\n        Result data as dictionary\n    ",
          "line_number": 56,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "visualize_as_graph",
          "signature": "(result: Dict[str, Any], output_path: Optional[str])",
          "docstring": "\n    Visualize the analysis as a graph.\n    \n    Args:\n        result: Analysis result data\n        output_path: Path to save the visualization\n    ",
          "line_number": 76,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "visualize_as_timeline",
          "signature": "(result: Dict[str, Any], output_path: Optional[str])",
          "docstring": "\n    Visualize the analysis as a timeline.\n    \n    Args:\n        result: Analysis result data\n        output_path: Path to save the visualization\n    ",
          "line_number": 141,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "visualize_as_table",
          "signature": "(result: Dict[str, Any])",
          "docstring": "\n    Visualize the analysis as a rich table.\n    \n    Args:\n        result: Analysis result data\n    ",
          "line_number": 235,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "main",
          "signature": "()",
          "docstring": "Main entry point.",
          "line_number": 322,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 10595,
      "line_count": 346
    }
  ],
  "utilities": [
    {
      "name": "config",
      "path": "config.py",
      "docstring": "\nConfiguration settings for Crypto Hunter\n",
      "imports": [
        "import os",
        "from typing import Dict",
        "from typing import List",
        "from typing import Any",
        "from dotenv import load_dotenv"
      ],
      "functions": [],
      "classes": [],
      "constants": [
        "PROJECT_NAME = 'Crypto Hunter'",
        "VERSION = '1.0.0'",
        "MAX_FILE_SIZE = 10 * 1024 * 1024",
        "CACHE_DIR = '.cache'",
        "DEFAULT_RESULTS_DIR = 'results'",
        "ANTHROPIC_API_KEY = os.getenv('ANTHROPIC_API_KEY')",
        "OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')",
        "ETHERSCAN_API_KEY = os.getenv('ETHERSCAN_API_KEY')",
        "LLM_CONFIG = {'anthropic': {'model': 'claude-3-5-sonnet-20240620', 'temperature': 0.3, 'max_tokens': 4000}, 'openai': {'model': 'gpt-4o-2024-05-13', 'temperature': 0.3, 'max_tokens': 4000}}",
        "ANALYZER_CONFIG = {'text_analyzer': {'enabled': True, 'priority': 10, 'max_text_length': 100000}, 'binary_analyzer': {'enabled': True, 'priority': 20, 'max_file_size': 5 * 1024 * 1024}, 'image_analyzer': {'enabled': True, 'priority': 30, 'supported_formats': ['png', 'jpg', 'jpeg', 'gif', 'bmp']}, 'blockchain_analyzer': {'enabled': True, 'priority': 40, 'supported_chains': ['ethereum', 'bitcoin']}, 'cipher_analyzer': {'enabled': True, 'priority': 50, 'supported_ciphers': ['caesar', 'vigenere', 'substitution', 'transposition', 'xor', 'aes', 'rsa']}, 'encoding_analyzer': {'enabled': True, 'priority': 60, 'supported_encodings': ['base64', 'base32', 'hex', 'ascii85', 'url', 'rot13']}}",
        "LOGGING_CONFIG = {'version': 1, 'formatters': {'standard': {'format': '%(asctime)s [%(levelname)s] %(name)s: %(message)s', 'datefmt': '%Y-%m-%d %H:%M:%S'}}, 'handlers': {'console': {'class': 'logging.StreamHandler', 'level': 'INFO', 'formatter': 'standard', 'stream': 'ext://sys.stdout'}, 'file': {'class': 'logging.FileHandler', 'level': 'DEBUG', 'formatter': 'standard', 'filename': 'crypto_hunter.log', 'mode': 'a'}}, 'loggers': {'': {'handlers': ['console', 'file'], 'level': 'INFO'}, 'crypto_hunter': {'handlers': ['console', 'file'], 'level': 'DEBUG', 'propagate': False}}}",
        "INTERACTIVE_CONFIG = {'prompt': 'crypto-hunter> ', 'intro_text': f\"\\nWelcome to {PROJECT_NAME} v{VERSION} Interactive Mode!\\nType 'help' for a list of commands, or 'exit' to quit.\\n    \", 'history_file': '.crypto_hunter_history'}",
        "PATTERN_REGEXES = {'ethereum_address': '0x[a-fA-F0-9]{40}', 'bitcoin_address': '[13][a-km-zA-HJ-NP-Z1-9]{25,34}', 'ipfs_hash': 'Qm[1-9A-HJ-NP-Za-km-z]{44}', 'url': 'https?://(?:[-\\\\w.]|(?:%[\\\\da-fA-F]{2}))+', 'base64': '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$', 'hex_string': '^[0-9a-fA-F]+$'}",
        "CRYPTO_TOOLS = {'common_ciphers': ['Caesar', 'Vigenère', 'Substitution', 'Transposition', 'XOR', 'AES', 'RSA', 'Atbash', 'Railfence', 'Playfair'], 'encodings': ['Base64', 'Base32', 'Hex', 'ASCII85', 'URL', 'ROT13', 'Binary'], 'steganography_tools': ['LSB Steganography', 'DCT Steganography', 'Echo Hiding', 'Metadata', 'Whitespace'], 'hash_functions': ['MD5', 'SHA-1', 'SHA-256', 'SHA-512', 'RIPEMD-160', 'Keccak-256']}",
        "CHALLENGE_PATTERNS = {'ctf_flags': ['flag{.*}', 'FLAG{.*}', 'ctf{.*}', 'CTF{.*}'], 'encoded_keywords': ['secret', 'password', 'key', 'flag', 'hidden', 'decrypt', 'solve']}"
      ],
      "file_size": 5615,
      "line_count": 239
    }
  ],
  "other": [
    {
      "name": "test_import",
      "path": "test_import.py",
      "docstring": "\nSimple test script to verify that the import error is fixed.\n",
      "imports": [
        "from analyzers import get_compatible_analyzers"
      ],
      "functions": [],
      "classes": [],
      "constants": [],
      "file_size": 288,
      "line_count": 10
    },
    {
      "name": "test",
      "path": "test.py",
      "docstring": "\nTest script for the enhanced image analyzer and state management\n",
      "imports": [
        "import sys",
        "import os",
        "from pathlib import Path",
        "from core.state import State",
        "from analyzers.image_analyzer import analyze_image",
        "from core.state import State",
        "from analyzers.base import get_all_analyzers"
      ],
      "functions": [
        {
          "name": "test_enhanced_state",
          "signature": "()",
          "docstring": "Test the enhanced state management",
          "line_number": 15,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "test_enhanced_image_analyzer",
          "signature": "()",
          "docstring": "Test the enhanced image analyzer",
          "line_number": 51,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "create_test_png",
          "signature": "()",
          "docstring": "Create a minimal test PNG for testing",
          "line_number": 80,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "test_analyzer_registration",
          "signature": "()",
          "docstring": "Test that analyzers are properly registered",
          "line_number": 99,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "test_dependencies",
          "signature": "()",
          "docstring": "Test that required dependencies are available",
          "line_number": 119,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "main",
          "signature": "()",
          "docstring": "Run all tests",
          "line_number": 144,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 5585,
      "line_count": 185
    },
    {
      "name": "quick_analyze",
      "path": "quick_analyze.py",
      "docstring": "\nQuick analysis script for Crypto Hunter project.\nRun this to get all the files needed for collaboration.\n",
      "imports": [
        "import os",
        "import sys",
        "from pathlib import Path",
        "from project_walker import ProjectWalker"
      ],
      "functions": [
        {
          "name": "quick_analyze",
          "signature": "()",
          "docstring": "Run a quick analysis and generate all useful output files.",
          "line_number": 17,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "create_collaboration_summary",
          "signature": "(project_info, full_summary)",
          "docstring": "Create a concise summary perfect for collaboration.",
          "line_number": 97,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 7490,
      "line_count": 192
    },
    {
      "name": "test_lsb_extraction",
      "path": "test_lsb_extraction.py",
      "docstring": "\nTest script to verify the fix for the encoding_analyzer issue with LSB data extraction.\n",
      "imports": [
        "import os",
        "import sys",
        "from PIL import Image",
        "import numpy",
        "from core.state import State",
        "from analyzers.image_analyzer import extract_lsb_rgb",
        "from analyzers.image_analyzer import analyze_lsb_data",
        "from analyzers.encoding_analyzer import detect_encoding",
        "from analyzers.image_analyzer import extract_lsb_rgb_region",
        "from analyzers.image_analyzer import extract_bit_plane",
        "import traceback",
        "import urllib.parse",
        "import re",
        "from itertools import cycle",
        "import html"
      ],
      "functions": [
        {
          "name": "main",
          "signature": "()",
          "docstring": null,
          "line_number": 14,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 10313,
      "line_count": 224
    },
    {
      "name": "test_keys",
      "path": "test_keys.py",
      "docstring": null,
      "imports": [
        "from eth_keys import keys",
        "from eth_utils import keccak",
        "from eth_utils import to_checksum_address"
      ],
      "functions": [],
      "classes": [],
      "constants": [],
      "file_size": 705,
      "line_count": 18
    },
    {
      "name": "test_code_agent",
      "path": "test_code_agent.py",
      "docstring": "\nTest script to verify the fix for the code_agent.py issue.\n",
      "imports": [
        "import logging",
        "import sys",
        "from core.code_agent import CodeAgent",
        "from core.code_agent import SafeExecutionEnvironment"
      ],
      "functions": [
        {
          "name": "test_safe_execution",
          "signature": "()",
          "docstring": "Test the SafeExecutionEnvironment with a simple code snippet.",
          "line_number": 13,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 1076,
      "line_count": 40
    },
    {
      "name": "install",
      "path": "install.py",
      "docstring": "\nInstallation script for Crypto Hunter\n\nThis script helps with setting up Crypto Hunter and its dependencies.\n",
      "imports": [
        "import os",
        "import sys",
        "import subprocess",
        "import platform",
        "import argparse",
        "from pathlib import Path",
        "from typing import List",
        "from typing import Optional"
      ],
      "functions": [
        {
          "name": "parse_arguments",
          "signature": "()",
          "docstring": "Parse command line arguments.",
          "line_number": 16,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "run_command",
          "signature": "(command: List[str], cwd: Optional[str]) -> bool",
          "docstring": "\n    Run a shell command.\n    \n    Args:\n        command: Command to run as a list of arguments\n        cwd: Working directory\n        \n    Returns:\n        True if command succeeded, False otherwise\n    ",
          "line_number": 46,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "create_virtual_environment",
          "signature": "(venv_path: str) -> bool",
          "docstring": "\n    Create a Python virtual environment.\n    \n    Args:\n        venv_path: Path for the virtual environment\n        \n    Returns:\n        True if successful, False otherwise\n    ",
          "line_number": 73,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "get_venv_python",
          "signature": "(venv_path: str) -> str",
          "docstring": "\n    Get the path to the Python interpreter in the virtual environment.\n    \n    Args:\n        venv_path: Path to the virtual environment\n        \n    Returns:\n        Path to the Python interpreter\n    ",
          "line_number": 92,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "get_venv_pip",
          "signature": "(venv_path: str) -> str",
          "docstring": "\n    Get the path to pip in the virtual environment.\n    \n    Args:\n        venv_path: Path to the virtual environment\n        \n    Returns:\n        Path to pip\n    ",
          "line_number": 108,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "install_dependencies",
          "signature": "(venv_path: str, dev: bool) -> bool",
          "docstring": "\n    Install dependencies.\n    \n    Args:\n        venv_path: Path to the virtual environment\n        dev: Whether to install development dependencies\n        \n    Returns:\n        True if successful, False otherwise\n    ",
          "line_number": 124,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "configure_api_keys",
          "signature": "()",
          "docstring": "Configure API keys for the project.",
          "line_number": 166,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "setup_project_structure",
          "signature": "()",
          "docstring": "Ensure the project structure is set up correctly.",
          "line_number": 252,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "main",
          "signature": "()",
          "docstring": "Main entry point.",
          "line_number": 262,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 8936,
      "line_count": 308
    },
    {
      "name": "project_walker",
      "path": "project_walker.py",
      "docstring": "\nProject Walker for Crypto Hunter\nGenerates a helicopter view of the entire project structure, functions, and classes.\n",
      "imports": [
        "import ast",
        "import os",
        "import json",
        "from pathlib import Path",
        "from typing import Dict",
        "from typing import List",
        "from typing import Any",
        "from typing import Optional",
        "from dataclasses import dataclass",
        "from dataclasses import asdict",
        "import argparse"
      ],
      "functions": [
        {
          "name": "main",
          "signature": "()",
          "docstring": null,
          "line_number": 432,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [
        {
          "name": "FunctionInfo",
          "docstring": null,
          "line_number": 15,
          "methods": [
            {
              "name": "__post_init__",
              "signature": "(self)",
              "docstring": null,
              "line_number": 23,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": [
            "dataclass"
          ]
        },
        {
          "name": "ClassInfo",
          "docstring": null,
          "line_number": 28,
          "methods": [
            {
              "name": "__post_init__",
              "signature": "(self)",
              "docstring": null,
              "line_number": 36,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": [
            "dataclass"
          ]
        },
        {
          "name": "ModuleInfo",
          "docstring": null,
          "line_number": 43,
          "methods": [],
          "base_classes": [],
          "decorators": [
            "dataclass"
          ]
        },
        {
          "name": "ProjectWalker",
          "docstring": "\n    Walks through a Python project and extracts structural information.\n    ",
          "line_number": 54,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self, root_path: str, exclude_dirs: List[str], exclude_files: List[str])",
              "docstring": null,
              "line_number": 59,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "extract_signature",
              "signature": "(self, node: ast.FunctionDef) -> str",
              "docstring": "Extract function signature as string.",
              "line_number": 69,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "extract_decorators",
              "signature": "(self, node) -> List[str]",
              "docstring": "Extract decorator names.",
              "line_number": 112,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "extract_docstring",
              "signature": "(self, node) -> Optional[str]",
              "docstring": "Extract docstring from a node.",
              "line_number": 122,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "extract_imports",
              "signature": "(self, tree: ast.AST) -> List[str]",
              "docstring": "Extract import statements.",
              "line_number": 131,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "extract_constants",
              "signature": "(self, tree: ast.AST) -> List[str]",
              "docstring": "Extract module-level constants (uppercase variables).",
              "line_number": 144,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "analyze_file",
              "signature": "(self, file_path: Path) -> Optional[ModuleInfo]",
              "docstring": "Analyze a single Python file.",
              "line_number": 158,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "walk_project",
              "signature": "(self) -> Dict[str, List[ModuleInfo]]",
              "docstring": "Walk the entire project and extract information.",
              "line_number": 244,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "generate_summary",
              "signature": "(self, project_info: Dict[str, List[ModuleInfo]]) -> str",
              "docstring": "Generate a human-readable summary.",
              "line_number": 279,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "save_detailed_json",
              "signature": "(self, project_info: Dict[str, List[ModuleInfo]], output_file: str)",
              "docstring": "Save detailed project information as JSON.",
              "line_number": 352,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "create_function_index",
              "signature": "(self, project_info: Dict[str, List[ModuleInfo]]) -> str",
              "docstring": "Create a searchable index of all functions and their purposes.",
              "line_number": 362,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [],
          "decorators": []
        }
      ],
      "constants": [],
      "file_size": 19711,
      "line_count": 477
    },
    {
      "name": "main",
      "path": "main.py",
      "docstring": "\nCrypto Hunter - The Ultimate Cryptographic Puzzle Solver\n\nA tool for analyzing and solving cryptographic puzzles using AI assistance.\n",
      "imports": [
        "import os",
        "import sys",
        "import argparse",
        "import json",
        "from pathlib import Path",
        "from rich.console import Console",
        "from rich.panel import Panel",
        "from rich.table import Table",
        "from rich.prompt import Prompt",
        "from rich.prompt import IntPrompt",
        "from rich import box",
        "from core.state import State",
        "from core.agent import CryptoAgent",
        "from core.utils import browse_puzzles",
        "from core.utils import get_puzzle_info",
        "from core.utils import setup_logging",
        "from core.utils import load_clues",
        "from core.utils import load_patterns",
        "from core.logger import solution_logger",
        "from ui.interactive import start_interactive_session",
        "from core.enhanced_state_saver import enhanced_saver",
        "from core.enhanced_state_saver import enhanced_saver",
        "import re",
        "from core.enhanced_state_saver import enhanced_saver",
        "from core.enhanced_state_saver import enhanced_saver"
      ],
      "functions": [
        {
          "name": "parse_arguments",
          "signature": "()",
          "docstring": "Parse command-line arguments.",
          "line_number": 27,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "display_welcome",
          "signature": "()",
          "docstring": "Display the welcome message.",
          "line_number": 50,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "setup_environment",
          "signature": "(args)",
          "docstring": "Set up the environment for the application.",
          "line_number": 61,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "interactive_menu",
          "signature": "()",
          "docstring": "Display the interactive menu.",
          "line_number": 75,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "select_provider_interactively",
          "signature": "()",
          "docstring": "Allow user to select an LLM provider.",
          "line_number": 92,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "print_state_details",
          "signature": "(state)",
          "docstring": "Print detailed insights and transformations from the state.",
          "line_number": 125,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "process_all_files_in_folder",
          "signature": "(folder_path, agent, output_dir, iterations, results_dir, use_clues, verbose)",
          "docstring": "\n    Process all files in a puzzle folder as a single puzzle.\n\n    Args:\n        folder_path: Path to the puzzle folder\n        agent: CryptoAgent instance for analysis\n        output_dir: Directory to store output files\n        iterations: Maximum number of iterations for the agent\n        results_dir: Directory to store results\n        use_clues: Whether to use available clues\n        verbose: Whether to print detailed reasoning\n\n    Returns:\n        Final state of the puzzle analysis\n    ",
          "line_number": 144,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "process_puzzle",
          "signature": "(puzzle_path, agent, output_dir, iterations, results_dir, use_clues, verbose)",
          "docstring": "\n    Process a single puzzle file or folder.\n\n    Args:\n        puzzle_path: Path to the puzzle file or folder\n        agent: CryptoAgent instance\n        output_dir: Directory to store output files\n        iterations: Maximum number of analysis iterations\n        results_dir: Directory to store results\n        use_clues: Whether to use available clues\n        verbose: Whether to print detailed reasoning\n\n    Returns:\n        Exit code (0 for success, non-zero for failure)\n    ",
          "line_number": 385,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "display_results",
          "signature": "(state, puzzle_path)",
          "docstring": "Display the analysis results in a structured format.",
          "line_number": 559,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "browse_puzzle_collection",
          "signature": "(puzzles_dir, agent, results_dir, use_clues, verbose)",
          "docstring": "Browse the puzzle collection interactively.",
          "line_number": 689,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "interactive_mode",
          "signature": "(agent)",
          "docstring": "Run in interactive mode.",
          "line_number": 798,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "read_last_results",
          "signature": "(results_dir)",
          "docstring": "\n    Read and display the most recent results file.\n\n    Args:\n        results_dir: Directory containing results files\n\n    Returns:\n        Exit code (0 for success, non-zero for failure)\n    ",
          "line_number": 806,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "main",
          "signature": "()",
          "docstring": "Main entry point for the application.",
          "line_number": 937,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 42520,
      "line_count": 1001
    },
    {
      "name": "ui.cli",
      "path": "ui/cli.py",
      "docstring": "\nCommand-line interface module for Crypto Hunter\n\nThis module provides the CLI interface for displaying information\nand results to the user.\n",
      "imports": [
        "import os",
        "import sys",
        "import logging",
        "import json",
        "import logging.config",
        "from typing import Dict",
        "from typing import List",
        "from typing import Any",
        "from typing import Optional",
        "from datetime import datetime",
        "from rich.console import Console",
        "from rich.panel import Panel",
        "from rich.table import Table",
        "from rich.syntax import Syntax",
        "from rich.logging import RichHandler",
        "from rich import box",
        "import config",
        "from core.state import State",
        "from rich.progress import Progress",
        "from rich.progress import TextColumn",
        "from rich.progress import BarColumn",
        "from rich.progress import TimeElapsedColumn"
      ],
      "functions": [
        {
          "name": "setup_logging",
          "signature": "(verbose: bool)",
          "docstring": "\n    Set up logging configuration.\n\n    Args:\n        verbose: Whether to enable verbose logging\n    ",
          "line_number": 29,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "display_banner",
          "signature": "()",
          "docstring": "Display the Crypto Hunter banner.",
          "line_number": 56,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "display_results",
          "signature": "(state: State)",
          "docstring": "\n    Display analysis results to the console.\n\n    Args:\n        state: The current puzzle state\n    ",
          "line_number": 70,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "display_analyzer_help",
          "signature": "()",
          "docstring": "Display help information about available analyzers.",
          "line_number": 179,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "save_results_to_file",
          "signature": "(state: State, file_path: str)",
          "docstring": "\n    Save analysis results to a file.\n\n    Args:\n        state: The current puzzle state\n        file_path: Path to save the results\n    ",
          "line_number": 222,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "print_error",
          "signature": "(message: str)",
          "docstring": "\n    Print an error message.\n\n    Args:\n        message: The error message\n    ",
          "line_number": 238,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "print_warning",
          "signature": "(message: str)",
          "docstring": "\n    Print a warning message.\n\n    Args:\n        message: The warning message\n    ",
          "line_number": 248,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "print_success",
          "signature": "(message: str)",
          "docstring": "\n    Print a success message.\n\n    Args:\n        message: The success message\n    ",
          "line_number": 258,
          "is_async": false,
          "decorators": []
        },
        {
          "name": "display_progress",
          "signature": "(current: int, total: int, message: str)",
          "docstring": "\n    Display a progress bar.\n\n    Args:\n        current: Current progress value\n        total: Total progress value\n        message: Progress message\n    ",
          "line_number": 268,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [],
      "constants": [],
      "file_size": 9582,
      "line_count": 287
    },
    {
      "name": "ui.interactive",
      "path": "ui/interactive.py",
      "docstring": "\nInteractive session module for Crypto Hunter.\nProvides an interactive shell for puzzle solving.\n",
      "imports": [
        "import cmd",
        "import sys",
        "from pathlib import Path",
        "from rich.console import Console",
        "from rich.panel import Panel",
        "from rich.table import Table",
        "from core.state import State",
        "from core.agent import CryptoAgent",
        "from analyzers import get_all_analyzers",
        "from analyzers import get_analyzer"
      ],
      "functions": [
        {
          "name": "start_interactive_session",
          "signature": "(agent: CryptoAgent)",
          "docstring": "Start an interactive session",
          "line_number": 183,
          "is_async": false,
          "decorators": []
        }
      ],
      "classes": [
        {
          "name": "InteractiveSession",
          "docstring": "Interactive command-line session for Crypto Hunter.",
          "line_number": 19,
          "methods": [
            {
              "name": "__init__",
              "signature": "(self, agent: CryptoAgent)",
              "docstring": null,
              "line_number": 28,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "do_load",
              "signature": "(self, line)",
              "docstring": "Load a puzzle file: load <filepath>",
              "line_number": 34,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "do_analyze",
              "signature": "(self, line)",
              "docstring": "Run analysis: analyze [analyzer_name] [iterations]",
              "line_number": 52,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "do_status",
              "signature": "(self, line)",
              "docstring": "Show current puzzle status",
              "line_number": 78,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "do_insights",
              "signature": "(self, line)",
              "docstring": "Show all insights: insights [count]",
              "line_number": 86,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "do_transformations",
              "signature": "(self, line)",
              "docstring": "Show transformations: transformations [count]",
              "line_number": 109,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "do_analyzers",
              "signature": "(self, line)",
              "docstring": "List available analyzers",
              "line_number": 127,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "do_solution",
              "signature": "(self, line)",
              "docstring": "Show solution if found",
              "line_number": 141,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "do_reset",
              "signature": "(self, line)",
              "docstring": "Reset the current session",
              "line_number": 151,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "do_exit",
              "signature": "(self, line)",
              "docstring": "Exit the interactive session",
              "line_number": 156,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "do_quit",
              "signature": "(self, line)",
              "docstring": "Exit the interactive session",
              "line_number": 161,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "_show_results",
              "signature": "(self)",
              "docstring": "Show brief analysis results",
              "line_number": 165,
              "is_async": false,
              "decorators": []
            },
            {
              "name": "emptyline",
              "signature": "(self)",
              "docstring": "Override to do nothing on empty line",
              "line_number": 179,
              "is_async": false,
              "decorators": []
            }
          ],
          "base_classes": [
            "cmd.Cmd"
          ],
          "decorators": []
        }
      ],
      "constants": [],
      "file_size": 6762,
      "line_count": 191
    }
  ]
}