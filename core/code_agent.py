# core/code_agent.py
"""
CodeAgent for Crypto Hunter.
Includes SafeExecutionEnvironment stub and DynamicToolRegistry.
"""
import os
import uuid
import logging
from typing import Any, Dict, List

# Stub so imports of SafeExecutionEnvironment don’t fail
class SafeExecutionEnvironment:
    """Dummy safe execution environment."""
    pass

class DynamicToolRegistry:
    """Registry for dynamic code-generated tools."""
    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        self.tools = {}  # tool_id → script path

    def register(self, tool_id: str, path: str):
        self.tools[tool_id] = path
        if self.verbose:
            logging.info(f"[ToolRegistry] Registered {tool_id} → {path}")

class CodeAgent:
    """
    Agent capable of writing and executing small Python tools based on state.
    """
    def __init__(self,
                 tools_dir: str = "tools",
                 max_execution_time: int = 30,
                 memory_limit: int = 100*1024*1024,
                 verbose: bool = False) -> None:
        """
        tools_dir: where to save generated scripts
        verbose:   whether to log creation/execution
        """
        self.tools_dir = tools_dir
        os.makedirs(self.tools_dir, exist_ok=True)
        self.max_execution_time = max_execution_time
        self.memory_limit = memory_limit
        self.verbose = verbose
        self.llm_plan = {}
        self.registry = DynamicToolRegistry(verbose=verbose)

    def receive_llm_plan(self, plan: Dict[str, Any]):
        self.llm_plan = plan
        if self.verbose:
            logging.info("[CodeAgent] Received LLM plan")

    def analyze_and_create_tools(self, state) -> List[str]:
        """
        Inspect state.findings for patterns and generate small scripts.
        Returns list of tool_ids created.
        """
        tool_ids: List[str] = []
        for f in state.get_high_confidence_findings():
            desc = f.get("description", "")
            # example: if we detect a hex key (0x...)
            if isinstance(desc, str) and desc.startswith("0x") and len(desc) > 10:
                tid = uuid.uuid4().hex
                path = os.path.join(self.tools_dir, f"tool_{tid}.py")
                with open(path, "w") as fd:
                    fd.write(f"""\
# auto-generated by CodeAgent
from Crypto.Cipher import AES
key = bytes.fromhex("{desc[2:]}")
print("KEY:", key.hex())
""")
                tool_ids.append(tid)
                self.registry.register(tid, path)
                if self.verbose:
                    logging.info(f"[CodeAgent] Generated tool_{tid}.py")
        return tool_ids

    def use_tool(self, tool_id: str, inputs: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the generated tool and return its output or error.
        """
        # find script path
        path = self.registry.tools.get(tool_id)
        if not path or not os.path.exists(path):
            return {"tool_id": tool_id, "error": "script not found"}
        try:
            # run in a fresh namespace
            ctx: Dict[str, Any] = {}
            code = open(path, "r").read()
            exec(code, ctx)
            return {"tool_id": tool_id, "output": ctx.get("print_output", "OK")}
        except Exception as e:
            return {"tool_id": tool_id, "error": str(e)}
