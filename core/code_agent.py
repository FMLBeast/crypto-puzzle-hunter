"""
CodeAgent for Crypto Hunter.
An agent capable of writing and executing its own code to solve puzzles.
"""

import ast
import importlib
import inspect
import json
import logging
import os
import re
import subprocess
import sys
import tempfile
import time
import traceback
import uuid
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Union

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class DynamicToolRegistry:
    """Registry for dynamically created tools."""

    def __init__(self, tools_dir: Union[str, Path] = "./dynamic_tools") -> None:
        """
        Initialize the tool registry.

        Args:
            tools_dir: Directory to store dynamically created tools
        """
        self.tools_dir = Path(tools_dir)
        self.tools_dir.mkdir(exist_ok=True)

        # Create __init__.py if it doesn't exist
        init_file = self.tools_dir / "__init__.py"
        if not init_file.exists():
            init_file.write_text("# Dynamic tools registry")

        self.tools: Dict[str, Dict[str, Any]] = {}
        self._load_existing_tools()

    def _load_existing_tools(self) -> None:
        """Load existing tools from the tools directory."""
        for py_file in self.tools_dir.glob("*.py"):
            if py_file.name == "__init__.py":
                continue
            try:
                module_name = py_file.stem
                spec = importlib.util.spec_from_file_location(
                    f"dynamic_tools.{module_name}", py_file
                )
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)  # type: ignore

                for name, obj in inspect.getmembers(module):
                    if inspect.isfunction(obj) and hasattr(obj, "_is_dynamic_tool"):
                        tool_id = getattr(obj, "_tool_id", name)
                        self.tools[tool_id] = {
                            "function": obj,
                            "name": name,
                            "description": getattr(obj, "_description", ""),
                            "module": module_name,
                            "file_path": py_file,
                            "code": inspect.getsource(obj),
                        }
                        logger.info(f"Loaded dynamic tool: {name}")
            except Exception as e:
                logger.error(f"Error loading tool from {py_file}: {e}")

    def register_tool(
        self, code: str, name: Optional[str] = None, description: str = ""
    ) -> Optional[str]:
        """
        Register a new tool from code.

        Args:
            code: Python code for the tool
            name: Optional name for the tool (extracted from code if not provided)
            description: Optional description of the tool

        Returns:
            Tool ID if successful, None otherwise
        """
        try:
            if not name:
                try:
                    tree = ast.parse(code)
                    for node in ast.walk(tree):
                        if isinstance(node, ast.FunctionDef):
                            name = node.name
                            break
                except Exception:
                    name = f"dynamic_tool_{uuid.uuid4().hex[:8]}"

            # Sanitize name
            name = re.sub(r"[^a-zA-Z0-9_]", "_", name)

            tool_id = f"{name}_{uuid.uuid4().hex[:8]}"
            module_name = f"tool_{uuid.uuid4().hex[:8]}"
            file_path = self.tools_dir / f"{module_name}.py"

            # Prepare tool code with decorator
            tool_code = f'''
# Dynamic tool generated by CodeAgent
# Description: {description}

def _register_dynamic_tool(func):
    func._is_dynamic_tool = True
    func._tool_id = "{tool_id}"
    func._description = "{description}"
    return func

@_register_dynamic_tool
{code}
'''

            file_path.write_text(tool_code)

            spec = importlib.util.spec_from_file_location(
                f"dynamic_tools.{module_name}", file_path
            )
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)  # type: ignore

            function = None
            for _, obj in inspect.getmembers(module):
                if inspect.isfunction(obj) and hasattr(obj, "_is_dynamic_tool"):
                    function = obj
                    break

            if function:
                self.tools[tool_id] = {
                    "function": function,
                    "name": name,
                    "description": description,
                    "module": module_name,
                    "file_path": file_path,
                    "code": code,
                }
                logger.info(f"Registered dynamic tool: {name} (ID: {tool_id})")
                return tool_id

            logger.error("Failed to find function in dynamic module")
            return None

        except Exception as e:
            logger.error(f"Error registering tool: {e}")
            return None

    def get_tool(self, tool_id: str) -> Optional[Callable]:
        """Get a tool by ID."""
        return self.tools.get(tool_id, {}).get("function")

    def list_tools(self) -> List[Dict[str, Any]]:
        """List all registered tools."""
        return [
            {
                "id": tool_id,
                "name": info["name"],
                "description": info["description"],
                "module": info["module"],
            }
            for tool_id, info in self.tools.items()
        ]

    def remove_tool(self, tool_id: str) -> bool:
        """Remove a tool by ID."""
        if tool_id not in self.tools:
            return False
        tool_info = self.tools[tool_id]
        try:
            os.remove(tool_info["file_path"])
            del self.tools[tool_id]
            logger.info(f"Removed dynamic tool: {tool_info['name']} (ID: {tool_id})")
            return True
        except Exception as e:
            logger.error(f"Error removing tool {tool_id}: {e}")
            return False


class SafeExecutionEnvironment:
    """
    Provides a safe environment for executing generated code.
    """

    def __init__(
        self,
        allowed_modules: Optional[List[str]] = None,
        max_execution_time: int = 10,
        memory_limit: int = 100 * 1024 * 1024,
    ) -> None:
        """
        Initialize the safe execution environment.

        Args:
            allowed_modules: List of allowed modules (None for default safe set)
            max_execution_time: Maximum execution time in seconds
            memory_limit: Memory limit in bytes
        """
        self.max_execution_time = max_execution_time
        self.memory_limit = memory_limit
        self.allowed_modules = allowed_modules or [
            "re",
            "math",
            "string",
            "datetime",
            "collections",
            "itertools",
            "functools",
            "operator",
            "json",
            "base64",
            "binascii",
            "hashlib",
            "os.path",
            "pathlib",
        ]

    def _create_safe_globals(self) -> Dict[str, Any]:
        """Create a safe globals dictionary."""
        safe_builtins = {
            "abs": abs,
            "all": all,
            "any": any,
            "bin": bin,
            "bool": bool,
            "bytearray": bytearray,
            "bytes": bytes,
            "chr": chr,
            "complex": complex,
            "dict": dict,
            "divmod": divmod,
            "enumerate": enumerate,
            "filter": filter,
            "float": float,
            "format": format,
            "frozenset": frozenset,
            "hash": hash,
            "hex": hex,
            "int": int,
            "isinstance": isinstance,
            "issubclass": issubclass,
            "iter": iter,
            "len": len,
            "list": list,
            "map": map,
            "max": max,
            "min": min,
            "next": next,
            "oct": oct,
            "ord": ord,
            "pow": pow,
            "print": print,
            "range": range,
            "repr": repr,
            "reversed": reversed,
            "round": round,
            "set": set,
            "slice": slice,
            "sorted": sorted,
            "str": str,
            "sum": sum,
            "tuple": tuple,
            "type": type,
            "zip": zip,
        }

        safe_globals = {"__builtins__": safe_builtins}

        for module_name in self.allowed_modules:
            try:
                if "." in module_name:
                    parts = module_name.split(".")
                    module = importlib.import_module(parts[0])
                    for part in parts[1:]:
                        module = getattr(module, part)
                else:
                    module = importlib.import_module(module_name)
                safe_globals[module_name.split(".")[-1]] = module
            except ImportError:
                logger.warning(f"Failed to import allowed module: {module_name}")

        return safe_globals

    def execute(self, code: str, inputs: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute code in a safe environment.

        Args:
            code: Python code to execute
            inputs: Optional dictionary of input variables

        Returns:
            Dictionary containing execution result
        """
        with tempfile.NamedTemporaryFile(suffix=".py", delete=False) as temp_file:
            temp_file_path = temp_file.name

        try:
            # Prepare wrapper code with safety checks
            wrapper_code = f'''
import sys
import os
import signal
import resource
import traceback

timeout = {self.max_execution_time}
memory_limit = {self.memory_limit}

def timeout_handler(signum, frame):
    raise TimeoutError(f"Code execution timed out after {{timeout}} seconds")

def check_memory_usage():
    usage = resource.getrusage(resource.RUSAGE_SELF)
    memory_usage = usage.ru_maxrss * 1024  # bytes
    if memory_usage > memory_limit:
        raise MemoryError(f"Memory usage exceeded limit: {{memory_usage}} bytes > {{memory_limit}} bytes")
    return memory_usage

signal.signal(signal.SIGALRM, timeout_handler)
signal.alarm(timeout)

memory_before = check_memory_usage()

__output__ = {{}}

try:
    {code}
    memory_after = check_memory_usage()
    __output__['memory_usage'] = memory_after - memory_before
    __output__['success'] = True
    __output__['error'] = None
except Exception as e:
    __output__['success'] = False
    __output__['error'] = str(e)
    __output__['traceback'] = traceback.format_exc()
finally:
    signal.alarm(0)

print("__output__ = " + repr(__output__))
'''

            with open(temp_file_path, "w", encoding="utf-8") as f:
                f.write(wrapper_code)

            env = os.environ.copy()

            process = subprocess.run(
                [sys.executable, temp_file_path],
                capture_output=True,
                text=True,
                env=env,
                timeout=self.max_execution_time + 2,
            )

            if process.returncode != 0:
                return {
                    "success": False,
                    "error": f"Process exited with code {process.returncode}",
                    "stdout": process.stdout,
                    "stderr": process.stderr,
                }

            # Extract __output__ dict from stdout
            output_match = re.search(r"__output__\s*=\s*(\{.*\})", process.stdout, re.DOTALL)
            if output_match:
                try:
                    output_dict = eval(output_match.group(1), {"__builtins__": {}})
                    return output_dict
                except Exception as e:
                    logger.error(f"Failed to parse output dict: {e}")

            # Fallback: return stdout and stderr
            return {"success": True, "stdout": process.stdout, "stderr": process.stderr}

        except subprocess.TimeoutExpired:
            return {"success": False, "error": f"Execution timed out after {self.max_execution_time} seconds"}
        except Exception as e:
            return {"success": False, "error": str(e), "traceback": traceback.format_exc()}
        finally:
            try:
                os.unlink(temp_file_path)
            except Exception:
                pass


class CodeAgent:
    """
    Agent capable of writing and executing its own code to solve puzzles.
    """

    def __init__(
        self,
        llm_agent: Optional[Any] = None,
        tools_dir: Union[str, Path] = "./dynamic_tools",
        max_execution_time: int = 10,
        memory_limit: int = 100 * 1024 * 1024,
    ) -> None:
        """
        Initialize the CodeAgent.

        Args:
            llm_agent: LLM agent for code generation
            tools_dir: Directory to store dynamically created tools
            max_execution_time: Maximum execution time in seconds
            memory_limit: Memory limit in bytes
        """
        self.llm_agent = llm_agent
        self.tool_registry = DynamicToolRegistry(tools_dir)
        self.execution_env = SafeExecutionEnvironment(
            max_execution_time=max_execution_time, memory_limit=memory_limit
        )
        self.code_history: List[Dict[str, Any]] = []

    def generate_code(
        self,
        task_description: str,
        state: Optional[Any] = None,
        required_outputs: Optional[List[str]] = None,
    ) -> str:
        """
        Generate code for a specific task.

        Args:
            task_description: Description of the task
            state: Current puzzle state (if available)
            required_outputs: List of required output variables

        Returns:
            Generated code
        """
        if not self.llm_agent or getattr(self.llm_agent, "fallback_mode", False):
            return self._generate_fallback_code(task_description, required_outputs)

        state_summary = state.get_summary() if state else "No state provided"
        available_tools = self.tool_registry.list_tools()
        tools_summary = json.dumps(available_tools, indent=2) if available_tools else "No tools available"

        prompt = f"""
You are an expert Python programmer tasked with writing code to solve a cryptographic puzzle.

TASK DESCRIPTION:
{task_description}

CURRENT PUZZLE STATE:
{state_summary}

AVAILABLE TOOLS:
{tools_summary}

Your task is to write Python code that accomplishes the described task.
The code should be a single function that takes appropriate inputs and returns a result.

Requirements:
1. The code should be clean, efficient, and well-commented
2. Focus on solving the specific task described
3. Assume the code will run in a restricted environment
4. If you need standard libraries, use only common ones like re, math, string, etc.
5. Your function should include proper docstrings and type hints
6. Return the results in a clear format

Write only the Python function without any additional explanation.
"""

        if required_outputs:
            prompt += f"\nThe function must return a dictionary with the following keys: {', '.join(required_outputs)}"

        try:
            result = self.llm_agent._send_to_llm(prompt)
            code_match = re.search(r"```(?:python)?\s*(.*?)\s*```", result, re.DOTALL)
            code = code_match.group(1) if code_match else result

            self.code_history.append(
                {"task": task_description, "code": code, "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")}
            )
            return code

        except Exception as e:
            logger.error(f"Error generating code: {e}")
            return self._generate_fallback_code(task_description, required_outputs)

    def _generate_fallback_code(self, task_description: str, required_outputs: Optional[List[str]] = None) -> str:
        """
        Generate fallback code templates for common tasks.

        Args:
            task_description: Description of the task
            required_outputs: List of required output variables

        Returns:
            Template code
        """
        task_lower = task_description.lower()

        if any(word in task_lower for word in ["base64", "encode", "decode"]):
            return self._template_base64_tool(required_outputs)
        if any(word in task_lower for word in ["xor", "cipher"]):
            return self._template_xor_tool(required_outputs)
        if any(word in task_lower for word in ["caesar", "rot", "shift"]):
            return self._template_caesar_tool(required_outputs)
        if any(word in task_lower for word in ["hash", "sha", "md5"]):
            return self._template_hash_tool(required_outputs)
        if any(word in task_lower for word in ["frequency", "analysis", "letter"]):
            return self._template_frequency_analysis_tool(required_outputs)
        return self._template_generic_analysis_tool(required_outputs)

    def _template_base64_tool(self, required_outputs: Optional[List[str]] = None) -> str:
        """Create a template for base64 encoding/decoding."""
        return '''
def base64_tool(data: str, mode: str = "decode") -> dict:
    """
    Encode or decode data using Base64.

    Args:
        data: The data to encode or decode
        mode: 'encode' or 'decode'

    Returns:
        Dictionary with the results
    """
    import base64

    result = {}

    try:
        if mode.lower() == "encode":
            encoded = base64.b64encode(data.encode('utf-8')).decode('utf-8')
            result['encoded'] = encoded
            result['success'] = True
        else:
            decoded = base64.b64decode(data).decode('utf-8')
            result['decoded'] = decoded
            result['success'] = True
    except Exception as e:
        result['success'] = False
        result['error'] = str(e)

    return result
'''

    def _template_xor_tool(self, required_outputs: Optional[List[str]] = None) -> str:
        """Create a template for XOR cipher."""
        return '''
def xor_cipher(data: str, key: str) -> dict:
    """
    Apply XOR cipher to the data using the given key.

    Args:
        data: The data to encrypt/decrypt
        key: The encryption key

    Returns:
        Dictionary with the results
    """
    result = {}

    try:
        data_bytes = data.encode('utf-8')
        key_bytes = key.encode('utf-8')

        output_bytes = bytearray()
        for i in range(len(data_bytes)):
            output_bytes.append(data_bytes[i] ^ key_bytes[i % len(key_bytes)])

        output_hex = output_bytes.hex()

        result['xor_result'] = output_hex
        result['success'] = True
    except Exception as e:
        result['success'] = False
        result['error'] = str(e)

    return result
'''

    def _template_caesar_tool(self, required_outputs: Optional[List[str]] = None) -> str:
        """Create a template for Caesar cipher."""
        return '''
def caesar_cipher(text: str, shift: int = None) -> dict:
    """
    Apply or break Caesar cipher.

    Args:
        text: The text to encrypt/decrypt
        shift: The shift amount (if None, try all shifts)

    Returns:
        Dictionary with the results
    """
    import string

    result = {}

    try:
        if shift is not None:
            alphabet = string.ascii_lowercase
            shifted_alphabet = alphabet[shift:] + alphabet[:shift]
            table = str.maketrans(alphabet, shifted_alphabet)

            output = text.lower().translate(table)
            result['shifted_text'] = output
            result['shift'] = shift
            result['success'] = True
        else:
            alphabet = string.ascii_lowercase
            all_shifts = {}

            for i in range(26):
                shifted_alphabet = alphabet[i:] + alphabet[:i]
                table = str.maketrans(alphabet, shifted_alphabet)
                all_shifts[i] = text.lower().translate(table)

            result['all_shifts'] = all_shifts
            result['success'] = True
    except Exception as e:
        result['success'] = False
        result['error'] = str(e)

    return result
'''

    def _template_hash_tool(self, required_outputs: Optional[List[str]] = None) -> str:
        """Create a template for hash functions."""
        return '''
def hash_tool(data: str, algorithm: str = "sha256") -> dict:
    """
    Calculate hash of the data using the specified algorithm.

    Args:
        data: The data to hash
        algorithm: Hash algorithm to use (md5, sha1, sha256, sha512)

    Returns:
        Dictionary with the results
    """
    import hashlib

    result = {}

    try:
        data_bytes = data.encode('utf-8')

        if algorithm == "md5":
            hash_obj = hashlib.md5(data_bytes)
        elif algorithm == "sha1":
            hash_obj = hashlib.sha1(data_bytes)
        elif algorithm == "sha256":
            hash_obj = hashlib.sha256(data_bytes)
        elif algorithm == "sha512":
            hash_obj = hashlib.sha512(data_bytes)
        else:
            raise ValueError(f"Unsupported algorithm: {algorithm}")

        result['hash'] = hash_obj.hexdigest()
        result['algorithm'] = algorithm
        result['success'] = True
    except Exception as e:
        result['success'] = False
        result['error'] = str(e)

    return result
'''

    def _template_frequency_analysis_tool(self, required_outputs: Optional[List[str]] = None) -> str:
        """Create a template for frequency analysis."""
        return '''
def frequency_analysis(text: str) -> dict:
    """
    Perform frequency analysis on the text.

    Args:
        text: The text to analyze

    Returns:
        Dictionary with the results
    """
    import string
    from collections import Counter

    result = {}

    try:
        cleaned_text = ''.join(c.lower() for c in text if c.lower() in string.ascii_lowercase)
        letter_counts = Counter(cleaned_text)
        total_letters = len(cleaned_text)

        frequencies = {letter: count / total_letters for letter, count in letter_counts.items()}
        sorted_frequencies = dict(sorted(frequencies.items(), key=lambda x: x[1], reverse=True))

        english_frequencies = {
            'e': 0.1202, 't': 0.0910, 'a': 0.0812, 'o': 0.0768, 'i': 0.0731,
            'n': 0.0695, 's': 0.0628, 'r': 0.0602, 'h': 0.0592, 'd': 0.0432,
            'l': 0.0398, 'u': 0.0288, 'c': 0.0271, 'm': 0.0261, 'f': 0.0230,
            'y': 0.0211, 'w': 0.0209, 'g': 0.0203, 'p': 0.0182, 'b': 0.0149,
            'v': 0.0111, 'k': 0.0069, 'x': 0.0017, 'q': 0.0011, 'j': 0.0010, 'z': 0.0007
        }

        potential_mappings = {}
        for i, (text_letter, _) in enumerate(sorted_frequencies.items()):
            english_letter = list(english_frequencies.keys())[i if i < 26 else 25]
            potential_mappings[text_letter] = english_letter

        result['frequencies'] = sorted_frequencies
        result['potential_mappings'] = potential_mappings
        result['success'] = True
    except Exception as e:
        result['success'] = False
        result['error'] = str(e)

    return result
'''

    def _template_generic_analysis_tool(self, required_outputs: Optional[List[str]] = None) -> str:
        """Create a template for generic text analysis."""
        return '''
def analyze_text(text: str) -> dict:
    """
    Perform general analysis on the text.

    Args:
        text: The text to analyze

    Returns:
        Dictionary with the results
    """
    import re
    import string
    from collections import Counter
    import binascii

    result = {}

    try:
        result['length'] = len(text)
        result['lines'] = text.count('\\n') + 1

        char_count = Counter(text)
        result['unique_chars'] = len(char_count)
        result['most_common_chars'] = char_count.most_common(10)

        hex_pattern = re.compile(r'^[0-9a-fA-F]+$')
        result['is_hex'] = bool(hex_pattern.match(text.strip()))

        if result['is_hex']:
            try:
                decoded = binascii.unhexlify(text.strip())
                result['hex_decoded'] = decoded.decode('utf-8', errors='replace')
            except Exception:
                pass

        base64_pattern = re.compile(r'^[A-Za-z0-9+/]+={0,2}$')
        result['is_base64'] = bool(base64_pattern.match(text.strip()))

        if result['is_base64']:
            import base64
            try:
                decoded = base64.b64decode(text.strip())
                result['base64_decoded'] = decoded.decode('utf-8', errors='replace')
            except Exception:
                pass

        binary_pattern = re.compile(r'^[01\\s]+$')
        result['is_binary'] = bool(binary_pattern.match(text.strip()))

        if result['is_binary']:
            try:
                binary_text = ''.join(text.strip().split())
                bytes_list = [binary_text[i:i+8] for i in range(0, len(binary_text), 8)]
                decoded = ''.join(chr(int(byte, 2)) for byte in bytes_list)
                result['binary_decoded'] = decoded
            except Exception:
                pass

        repeated_sequences = []
        for length in range(3, 10):
            sequences = {}
            for i in range(len(text) - length + 1):
                seq = text[i : i + length]
                sequences[seq] = sequences.get(seq, 0) + 1

            repeated_sequences.extend([(seq, count) for seq, count in sequences.items() if count > 1])

        repeated_sequences.sort(key=lambda x: x[1], reverse=True)
        result['repeated_sequences'] = repeated_sequences[:10]

        result['success'] = True
    except Exception as e:
        result['success'] = False
        result['error'] = str(e)

    return result
'''

    def execute_code(self, code: str, inputs: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute the generated code safely.

        Args:
            code: Python code to execute
            inputs: Optional dictionary of input variables

        Returns:
            Execution results
        """
        return self.execution_env.execute(code, inputs)

    def register_new_tool(self, task_description: str, state: Optional[Any] = None) -> Optional[str]:
        """
        Generate and register a new tool based on the task description.

        Args:
            task_description: Description of the tool to create
            state: Current puzzle state (if available)

        Returns:
            Tool ID if successful, None otherwise
        """
        code = self.generate_code(task_description, state)
        tool_name = None
        match = re.search(r"def\s+(\w+)", code)
        if match:
            tool_name = match.group(1)
        return self.tool_registry.register_tool(code, name=tool_name, description=task_description)

    def use_tool(self, tool_id: str, inputs: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Use a registered tool.

        Args:
            tool_id: ID of the tool to use
            inputs: Input parameters for the tool

        Returns:
            Tool execution results
        """
        tool = self.tool_registry.get_tool(tool_id)
        if not tool:
            return {"success": False, "error": f"Tool not found: {tool_id}"}

        try:
            result = tool(**inputs) if inputs else tool()
            return {"success": True, "result": result}
        except Exception as e:
            return {"success": False, "error": str(e), "traceback": traceback.format_exc()}

    def analyze_and_create_tools(self, state: Any) -> List[str]:
        """
        Analyze the puzzle state and create appropriate tools.

        Args:
            state: Current puzzle state

        Returns:
            List of created tool IDs
        """
        if not self.llm_agent or getattr(self.llm_agent, "fallback_mode", False):
            logger.info("No LLM available for tool creation, using defaults")
            return self._create_default_tools()

        state_summary = state.get_summary()
        prompt = f"""
Analyze this puzzle state and identify 3-5 specialized tools that would be helpful for solving it.
For each tool, provide a short description of what it should do.

PUZZLE STATE:
{state_summary}

FORMAT YOUR RESPONSE AS A JSON ARRAY OF OBJECTS:
[
  {{
    "name": "tool_name",
    "description": "what this tool should do"
  }},
  ...
]
"""
        try:
            result = self.llm_agent._send_to_llm(prompt)
            json_match = re.search(r"\[\s*{.*}\s*\]", result, re.DOTALL)
            if json_match:
                suggested_tools = json.loads(json_match.group(0))
            else:
                logger.warning("Failed to parse tool suggestions from LLM, using defaults")
                return self._create_default_tools()

            created_tool_ids = []
            for tool_info in suggested_tools:
                tool_name = tool_info.get("name", "")
                tool_description = tool_info.get("description", "")
                tool_id = self.register_new_tool(
                    f"Create a tool named '{tool_name}' that {tool_description}", state
                )
                if tool_id:
                    created_tool_ids.append(tool_id)

            return created_tool_ids

        except Exception as e:
            logger.error(f"Error analyzing and creating tools: {e}")
            return self._create_default_tools()

    def _create_default_tools(self) -> List[str]:
        """Create a set of default tools for cryptographic puzzles."""
        default_descriptions = [
            "Create a tool for analyzing text frequency patterns",
            "Create a tool for brute-forcing Caesar ciphers",
            "Create a tool for detecting and decoding common encodings",
            "Create a tool for XOR cipher operations",
            "Create a tool for extracting hidden data from text",
        ]

        created_tool_ids = []
        for desc in default_descriptions:
            tool_id = self.register_new_tool(desc)
            if tool_id:
                created_tool_ids.append(tool_id)
        return created_tool_ids

    def integrate_with_state(self, state: Any, analyze_puzzle: bool = True) -> Any:
        """
        Integrate code analysis with the puzzle state.

        Args:
            state: Current puzzle state
            analyze_puzzle: Whether to analyze the puzzle and create tools

        Returns:
            Updated state
        """
        state.add_insight("CodeAgent initialized for dynamic code analysis", analyzer="code_agent")

        if analyze_puzzle:
            tool_ids = self.analyze_and_create_tools(state)
            if tool_ids:
                state.add_insight(f"Created {len(tool_ids)} custom analysis tools", analyzer="code_agent")

                tools = []
                for tool_id in tool_ids:
                    tool_info = next(
                        (info for info in self.tool_registry.list_tools() if info["id"] == tool_id), None
                    )
                    if tool_info:
                        tools.append(f"{tool_info['name']}: {tool_info['description']}")

                state.add_insight(f"Available tools: {', '.join(tools)}", analyzer="code_agent")

        if getattr(state, "puzzle_text", None):
            state.add_insight("Performing general text analysis", analyzer="code_agent")

            analysis_code = self.generate_code("Create a function to perform general analysis on the puzzle text", state)
            result = self.execute_code(analysis_code, {"text": state.puzzle_text})

            if result.get("success"):
                analysis_result = result.get("result", {})
                for key, value in analysis_result.items():
                    if key != "success" and not key.startswith("_"):
                        state.add_insight(f"Analysis - {key}: {value}", analyzer="code_agent")
            else:
                state.add_insight(f"Code analysis failed: {result.get('error', 'Unknown error')}", analyzer="code_agent")

        return state
